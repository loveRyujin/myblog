<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>go网络编程</title>
      <link href="/2024/07/24/go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/07/24/go%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="启动一个简单的http服务"><a href="#启动一个简单的http服务" class="headerlink" title="启动一个简单的http服务"></a>启动一个简单的http服务</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">http.HandleFunc(<span class="string">&quot;/ping&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">w.Write([]<span class="type">byte</span>(<span class="string">&quot;pong&quot;</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">http.ListenAndServe(<span class="string">&quot;:8091&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;调用http.HandleFunc方法，注册对应请求路径下的处理函数,调用http.ListenAndServe方法，启动端口号为8091的http服务。</p><p>&emsp;&emsp;在浏览器输入<a href="http://localhost:8091/ping后，可以看到页面上的pong">http://localhost:8091/ping后，可以看到页面上的pong</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++知识点回顾</title>
      <link href="/2024/02/01/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/02/01/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="C-中的sizeof关键字"><a href="#C-中的sizeof关键字" class="headerlink" title="C++中的sizeof关键字"></a>C++中的sizeof关键字</h2><p>是c语言中的运算符，计算一个类型/对象所占用的内存的大小。</p><ul><li>指针的大小是固定的。32位处理器就是4字节，64位处理器就是8字节</li><li>数组当函数参数时会退化为指针，大小按指针算</li><li>计算struct大小时要考虑内存对齐</li><li>字符串数组大小要包含最后的’\0’</li></ul><h2 id="C-中的const关键字"><a href="#C-中的const关键字" class="headerlink" title="C++中的const关键字"></a>C++中的const关键字</h2><p>用于表示常量。</p><ul><li>修饰变量时代表该变量只读</li><li>修饰指针时用于声明本身为只读变量或者指向只读变量的指针</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;<span class="comment">//指向只读变量的指针，可以改变指针的指向，不能通过指针修改所指向只读变量的值</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line">p = &amp;a;<span class="comment">//合法，可以指向普通变量</span></span><br><span class="line">p = &amp;b;<span class="comment">//合法，可以指向只读变量</span></span><br><span class="line">*p = <span class="number">30</span>;<span class="comment">//非法，不能通过指针修改只读变量的值</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;a;<span class="comment">//只读指针,指向a</span></span><br><span class="line">*p = <span class="number">30</span>;<span class="comment">//合法，可以通过指针修改指向变量的值</span></span><br><span class="line">p = &amp;b;<span class="comment">//非法，不能修改指针（即修改指针的指向）</span></span><br></pre></td></tr></table></figure><h2 id="C-字节对齐"><a href="#C-字节对齐" class="headerlink" title="C++字节对齐"></a>C++字节对齐</h2><p>C++字节对齐是对内存分配的一种策略。编译器会自动调整数据结构在内存中的分布。如果不对内存中的数据进行适当的对齐而只是顺序排列，会降低存取效率。</p><p>优点：提高了内存访问的效率l</p><p>缺点：浪费内存空间</p><h2 id="typedef和define的区别"><a href="#typedef和define的区别" class="headerlink" title="typedef和define的区别"></a>typedef和define的区别</h2><p>define用于定义预处理宏，在预处理阶段进行处理，在编译之前有预处理器进行文本替换。无类型检查。全局有效。</p><p>typedef用于为现有的数据类型创建别名，在编译时进行处理。提供类型检查，保证类型安全。有作用域，仅定义它的作用域内有效。</p><h2 id="C-中class和struct的区别"><a href="#C-中class和struct的区别" class="headerlink" title="C++中class和struct的区别"></a>C++中class和struct的区别</h2><p>C++兼容了C中的struct，并扩展其含义。在C中，struct只能包含成员变量，不能包含成员函数，而C++中既可包含成员变量，又可定义成员函数。类似class。</p><p>不同点：</p><ul><li>class中成员默认是private，struct中默认是public</li><li>class继承默认是private继承，struct继承默认是public继承</li><li>class可以用来定义模板参数，struct则不行</li></ul><h2 id="C-内联函数（inline）"><a href="#C-内联函数（inline）" class="headerlink" title="C++内联函数（inline）"></a>C++内联函数（inline）</h2><p>函数声明前加上inline，编译器会尝试用函数体替换内联函数调用处，从而避免函数调用的开销。</p><p>但是编译器不一定会将所有声明为内联函数的函数都进行内联，是否执行取决于编译器的优化和是实现策略。优点是类型安全，可调试，可优化。同时注意由于函数体会被复制多次，会占用代码段空间，有些情况下会导致代码膨胀。</p><h2 id="C-类型转换"><a href="#C-类型转换" class="headerlink" title="C++类型转换"></a>C++类型转换</h2><ul><li><p>static_cast</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本类型之间的转换</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(a);<span class="comment">//将整数a转换为双精度浮点数b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针之间的转换</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span>: <span class="keyword">public</span> Base&#123;&#125;</span><br><span class="line"></span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="comment">//将基类的base_ptr转换为派生类的derived_ptr</span></span><br><span class="line">Derived* derived_ptr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(base_ptr);</span><br><span class="line"></span><br><span class="line">Derived derived_obj;</span><br><span class="line">Base&amp; base_ref = derived_obj;</span><br><span class="line"><span class="comment">//将基类的引用转换为派生类的引用</span></span><br><span class="line">Derived&amp; derived_ref = <span class="built_in">static_cast</span>&lt;Derived&amp;&gt;(base_ref);</span><br></pre></td></tr></table></figure><p>static_cast在编译器进行类型转换，在进行指针或引用转换时，保证转换合法。</p></li><li><p>dynamic_cast</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"></span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"><span class="comment">// 将基类指针base_ptr转换为派生类指针derived_ptr，如果类型兼容，则成功</span></span><br><span class="line">Derived* derived_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base_ptr); </span><br><span class="line"></span><br><span class="line"><span class="comment">//用于多态类型检查</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123; <span class="keyword">public</span>: <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123; <span class="keyword">public</span>: <span class="function"><span class="type">void</span> <span class="title">meow</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">Animal* animal_ptr = <span class="comment">/* ... */</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将Animal指针转换为Dog指针</span></span><br><span class="line">Dog* dog_ptr = <span class="built_in">dynamic_cast</span>&lt;Dog*&gt;(animal_ptr);</span><br><span class="line"><span class="keyword">if</span> (dog_ptr) &#123;</span><br><span class="line">    dog_ptr-&gt;<span class="built_in">bark</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试将Animal指针转换为Cat指针</span></span><br><span class="line">Cat* cat_ptr = <span class="built_in">dynamic_cast</span>&lt;Cat*&gt;(animal_ptr);</span><br><span class="line"><span class="keyword">if</span> (cat_ptr) &#123;</span><br><span class="line">    cat_ptr-&gt;<span class="built_in">meow</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>dynamic_cast主要应用于父类与子类中的安全类型转换，在运行时执行类型检查，所以相比static_cast其更安全。</p></li></ul><p>dynamic_cast要想有效，基类必须有虚函数（虚函数表），这样才有可能将基类指针转换为子类。</p><ul><li><p>const_cast</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以修改const属性，使得可以修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span>* mutable_ptr = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;a);</span><br><span class="line">*mutable_ptr = <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>const_cast<new type> (expression)，new type必须是一个指针、引用或者指向对象类型成员的指针。</p></li><li><p>reinterpret_cast</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *int_ptr = &amp;a;</span><br><span class="line"><span class="type">char</span> *char_ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(int_ptr);</span><br></pre></td></tr></table></figure><p>字面意义上看是重新翻译转型，就是重新解释底层bit，而不做任何类型检查。</p></li></ul><h2 id="C-面向对象三大特性"><a href="#C-面向对象三大特性" class="headerlink" title="C++面向对象三大特性"></a>C++面向对象三大特性</h2><ul><li>封装</li></ul><p>封装就是将数据（属性）和操作这些数据的函数（方法）组合在一个类中的过程。隐藏了类的内部实现细节，仅暴露必要的接口给外部。</p><ul><li>继承</li></ul><p>继承是一个类从另一个类获取属性和方法的过程，允许我们创建类层次的代码结构，减少重复代码，提高代码的复用性和可维护性。</p><ul><li>多态</li></ul><p>多态是允许不同的类对象使用相同的接口名字，但具有不同的实现特性。<br>C++中多态主要通过虚函数和抽象基类来实现。</p><p>虚函数允许派生类实现基类的方法，而抽象基类包含至少一个纯虚函数，无法被实例化，只能作为其它派生类的基类。</p><p>通过多态，可以编写更加通用的代码，提高代码的灵活性。</p><h2 id="C-类初始化和析构顺序"><a href="#C-类初始化和析构顺序" class="headerlink" title="C++类初始化和析构顺序"></a>C++类初始化和析构顺序</h2><p>初始化顺序：</p><p>1、首先是基类初始化顺序。如果当前的类继承自一或多个类，按照声明顺序进行初始化，但是有虚继承的话，优先虚继承。</p><p>2、成员变量初始化。按照在类中声明的顺序进行初始化。</p><p>3、执行该类构造函数。</p><p>析构顺序和初始化顺序相反。</p><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>浅拷贝（shallow copy）是一种简单的拷贝方式，仅复制对象的基本类型成员和指针成员的值，而不复制指针所指向的内存。这样会导致两个类对象使用相同的内存，产生内存泄漏等问题。一般地，默认编译器实现的拷贝构造函数是浅拷贝。</p><p>深拷贝（deep copy）包含浅拷贝的情况下，还复制指针指向的内存，所以两个对象不用共享相同资源，避免潜在错误。深拷贝的实现通常需要自定义拷贝构造函数和重载=运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> <span class="type">char</span>* str) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝的拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深拷贝的赋值运算符重载</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;other) &#123;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">SetString</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (data != <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">delete</span>[] data;</span><br><span class="line">     &#125;</span><br><span class="line">     data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">     <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line">    MyClass obj2 = obj1; <span class="comment">// 深拷贝</span></span><br><span class="line"></span><br><span class="line">    obj1.<span class="built_in">print</span>(); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">    obj2.<span class="built_in">print</span>(); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改obj2中的数据，不会影响obj1</span></span><br><span class="line">    obj1.<span class="built_in">SetString</span>(<span class="string">&quot;Test&quot;</span>);</span><br><span class="line">    obj2.<span class="built_in">print</span>(); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-多态实现的方式"><a href="#C-多态实现的方式" class="headerlink" title="C++多态实现的方式"></a>C++多态实现的方式</h2><p>C++中的多态指的是一个函数或者操作在不同的对象上有不同的表现方式，主要包括虚函数、纯虚函数和模板函数。虚函数和纯虚函数实现的多态称为动态多态，模板函数、重载实现的多态称为静态多态。</p><p>静态和动态的区别在于是在编译期还是运行时。</p><p>虚函数是基类声明的可以被派生类重写的函数。使用指向基类的指针或者引用可以调用被派生类重写的函数，实现多态。</p><ul><li>通过基类指针或引用调用虚函数</li><li>被调用的函数是虚函数且必须被派生类重写</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Rectangle class area :&quot;</span>; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Triangle class area :&quot;</span>; </span><br><span class="line">         <span class="keyword">return</span> (width * height / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line"></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板函数可以根据传递参数的不同类型，自动生成相应类型的函数代码，从而实现多态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">GetMax</span> <span class="params">(T a, T b)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> (a&gt;b?a:b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> i=<span class="number">5</span>, j=<span class="number">6</span>, k;</span><br><span class="line">   <span class="type">long</span> l=<span class="number">10</span>, m=<span class="number">5</span>, n;</span><br><span class="line">   k=<span class="built_in">GetMax</span>&lt;<span class="type">int</span>&gt;(i,j);</span><br><span class="line">   n=<span class="built_in">GetMax</span>&lt;<span class="type">long</span>&gt;(l,m);</span><br><span class="line">   cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会生成两个GetMax函数实例，参数类型分别为int和long。</p><h2 id="C-RAII思想"><a href="#C-RAII思想" class="headerlink" title="C++ RAII思想"></a>C++ RAII思想</h2><p>RAII即Resource Acqusition is Initialization，资源获取即初始化。</p><p>RAII将资源的生命周期与对象的作用域关联起来，核心思想是将资源（如内存、文件句柄、网络连接等）的获取和释放与对象的生命周期绑定在一起，利用栈上局部变量的自动析构来保证资源一定会被释放。</p><p>一般设计一个RAII类的四个步骤：</p><ul><li>设计一个类封装资源</li><li>在构造函数中执行资源的初始化，比如申请内存、打开文件、申请锁</li><li>在析构函数中执行销毁资源，比如释放内存、关闭文件、释放锁</li><li>使用时声明一个该类的对象</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">myfile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>; <span class="comment">// 换自己的文件路径</span></span><br><span class="line">    <span class="keyword">if</span> (myfile.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File is opened.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// do some work with the file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    myfile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码手动实现文件的打开与关闭，但是当程序异常退出时，可能导致打开的文件没有关闭，导致资源的泄露。这是可以利用RAII的思想进行改进，如下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">File</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">File</span>(<span class="type">const</span> <span class="type">char</span>* filename) : <span class="built_in">m_handle</span>(std::ifstream(filename)) &#123;&#125;</span><br><span class="line">    ~<span class="built_in">File</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_handle.<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;File is closed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            m_handle.<span class="built_in">close</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ifstream&amp; <span class="title">getHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_handle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::ifstream m_handle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">File <span class="title">myfile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (myfile.<span class="built_in">getHandle</span>().<span class="built_in">is_open</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;File is opened.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// do some work with the file</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个File类，构造函数中实现打开文件，析构函数中实现关闭文件，这样即使程序遇到异常退出，析构函数也能保证文件的关闭，从而不会发生内存泄漏等问题。</p><p>RAII思想也可以包装mutex：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LockGuard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">LockGuard</span><span class="params">(std::mutex &amp;mtx)</span> : mutex_(mtx) &#123;</span></span><br><span class="line">        mutex_.<span class="built_in">lock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">LockGuard</span>() &#123;</span><br><span class="line">        mutex_.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止复制</span></span><br><span class="line">    <span class="built_in">LockGuard</span>(<span class="type">const</span> LockGuard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LockGuard &amp;<span class="keyword">operator</span>=(<span class="type">const</span> LockGuard &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex &amp;mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 互斥量</span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"><span class="comment">// 多线程操作的变量</span></span><br><span class="line"><span class="type">int</span> shared_data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">        <span class="comment">// 申请锁</span></span><br><span class="line">        <span class="function">LockGuard <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        ++shared_data;</span><br><span class="line">        <span class="comment">// 作用域结束后会析构 然后释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t1</span><span class="params">(increment)</span></span>;</span><br><span class="line">    <span class="function">std::thread <span class="title">t2</span><span class="params">(increment)</span></span>;</span><br><span class="line"></span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Shared data: &quot;</span> &lt;&lt; shared_data &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-智能指针"><a href="#C-智能指针" class="headerlink" title="C++智能指针"></a>C++智能指针</h2><ul><li>std::shared_ptr</li></ul><p>表示一个共享所有权的智能指针，它允许多个shared_ptr指向同一个对象，当最后一个shared_ptr超出作用域时，其所指向的内存才会被自动释放。</p><p>std::shared_ptr实现的关键是引用计数。shared_ptr内部存储了一个指向堆内存的指针，将计数变量存储在堆上。</p><p>shared_ptr可能会导致double free问题，即同一块内存可能会被释放两次。<br>解决该问题的方法：</p><ul><li>使用make_shared函数创建shared_ptr实例，而不直接使用原始指针来创建，这样就确保所有的shared_ptr共享一个引用计数</li><li>对于出现循环引用的情况，使用weak_ptr<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1; <span class="comment">// 通过拷贝构造函数创建一个新的shared_ptr，此时引用计数为2</span></span><br><span class="line">    std::cout &lt;&lt; *ptr1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *ptr2 &lt;&lt; std::endl; <span class="comment">// 输出10 10</span></span><br><span class="line">    <span class="comment">// ptr2超出作用域时，所指向的内存不会被释放，因为此时ptr1仍然持有对该内存的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>实现一个简易版本的shared_ptr<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一个简易版本的shared_ptr</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimperSharedPtr</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SimperSharedPtr</span><span class="params">(T *_ptr = <span class="literal">nullptr</span>)</span>: ptr(_ptr), count(ptr ? new size_t(<span class="number">1</span>) : nullptr)&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SimperSharedPtr</span>(<span class="type">const</span> SimperSharedPtr&amp; other): <span class="built_in">ptr</span>(other.ptr), <span class="built_in">count</span>(other.count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count) &#123;</span><br><span class="line">            ++ (*count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   SimperSharedPtr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SimperSharedPtr&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="built_in">release</span>();</span><br><span class="line">            ptr = other.ptr;</span><br><span class="line">            count = other.count;</span><br><span class="line">            <span class="keyword">if</span> (count) &#123;</span><br><span class="line">                ++ (*count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">    ~ <span class="built_in">SimperSharedPtr</span>() &#123;</span><br><span class="line">        <span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &amp;&amp; -- (*count) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">            <span class="keyword">delete</span> ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span>* count;</span><br><span class="line">    T* ptr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>std::unique_ptr</li></ul><p>表示一个独占所有权的智能指针，保证指向的内存只能被unique_ptr拥有。当它超过作用域时其所指向的内存会自动释放。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 输出5</span></span><br><span class="line">    <span class="comment">// unique_ptr在超出作用域时自动释放所拥有的内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>智能指针可以提高程序的安全性和可靠性，避免内存泄漏和野指针的问题。</p><h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis知识点总结</title>
      <link href="/2024/02/01/golang%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/02/01/golang%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang内存模型"><a href="#Golang内存模型" class="headerlink" title="Golang内存模型"></a>Golang内存模型</h2><p>golang内存分配参考了tcmalloc的思路，即thread cache malloc。tcmalloc分为ThreadCache、CentralCache和PageHeap三个层次。</p><p>ThreadCache是对每一个线程的缓存，分配时不需要加锁，因为是每一个线程独有的，速度较快。其对每一个size class维护一个freeList，缓存没有被分配的空闲对象。</p><p>CentralCache也对每个size class维护一个freeList，但是是被多个线程共享的，分配时需要加锁。</p><p>当CentralCache不够分配时，就会像PageHeap申请内存，这部分内存可能来自PageHeap的缓存，也有可能是PageHeap向操作系统申请的新内存。</p><p>tcmalloc减少了在多线程的环境下，争夺锁所产生的开销，原因主要有二：1、在ThreadCache层面，此时是被每个线程单独占有的，不需要申请锁，加快了速度；2、由于是一次性向操作系统申请了一大块内存，就不需要频繁的系统调用来申请内存（系统调用需要上下文切换，开销比价大），加快了内存分配的效率。</p><p>Golang内存管理组件主要包括mspan、mcache、mcentral、mheap。</p><p>当程序初始化的时候，每个processor会给微对象和小对象分配mcache，其中包含内存管理单元mspan。内存管理单元分为很多特定大小的类（从8B到32KB），当向mcache中内存大小不够的时候，就会向mcentral中申请内存，mcentral就会根据对应的mspan的类型进行分配。mcentral又属于mheap，mheap负责向操作系统申请内存。</p><h3 id="mspan"><a href="#mspan" class="headerlink" title="mspan"></a>mspan</h3><p>mspan是Golang内存分配的基本单元。有67种类型。</p><ul><li>微对象。大小为（0， 16B），会先从微型分配器中分配，再依次尝试mcache、mcentral、mheap</li><li>小对象。大小为【16B、32KB】，申请顺序依次为mcache、mcentral、mheap</li><li>大对象。大小32KB以上，直接在mheap上分配</li></ul><p>mspan结构体中包含prev和next两个指针，用于访问双向链表中的前驱和后继节点（指的是在freeList中）</p><p>span直译为跨度，可以理解为一段连续的内存。mspan包含多个大小为8KB的页，这里的页并非操作系统中的页，是它们大小的整数倍。</p><p>结构体中还包含spanclass字段，用来表示mspan的类型和大小，go中一共有67种span类型，每个spanclass存储特定大小的对象，所有的数据会预先计算出来并存储下来，便于查找，以空间换时间。除开这67种spanclass，还有0号spanclass，用来管理大于32KB的对象。</p><h3 id="mcache"><a href="#mcache" class="headerlink" title="mcache"></a>mcache</h3><p>go中的线程缓存，其与go中的processor绑定，每个线程都会分配一个mcache处理微对象和小对象，是每个线程独有的，不需要加锁。   </p><p>mcache在初始化时不包含mspan，只有当第一次申请内存时，会向上一级组件申请获得mspan</p><h3 id="mcentral"><a href="#mcentral" class="headerlink" title="mcentral"></a>mcentral</h3><p>是Golang中的中心缓存，和mcache的区别是被多个线程共享，访问mcentral中的内存管理单元需要使用互斥锁。</p><p>每个mcentral会管理某个spanclass的内存管理单元，会分为两类，一个是包含空闲对象的内存管理单元，一个是不包含空闲管理对象的内存管理单元。</p><h3 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h3><p>内存分配的核心组件。包含mcentral和heapArena，堆上所有的mspan都是由mheap而来。</p><ul><li>allspans：已经分配的所有mspan</li><li>arenas：heapArena数组，用于管理一个个内存块</li><li>central：mcentral数组，用于管理对应spanclass的mspan</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Go的内存分配器根据对象的大小：分为微对象、小对象和大对象，分别采取不同的分配策略。</p><p>总体分配流程：32KB以上的对象，直接从mheap中进行分配；小于等于16KB的对象从mcache中的微型分配器中进行分配；剩下的小对象的话，首先计算对象的大小，然后mcache分配对应规格的mspan，如果mcache中没有对应规格的mspan，就会向mcentral中申请，若mcentral中也没有，就会继续向mheap申请，如果mheap中也没有，就会向操作系统进行申请。</p><h2 id="Golang-map实现原理"><a href="#Golang-map实现原理" class="headerlink" title="Golang map实现原理"></a>Golang map实现原理</h2><p>算法上基于hash实现key的映射和寻址；在数据结构上基于桶数组实现key-value对的存储。</p><p>流程：</p><ul><li>通过hash取得key的hash值；</li><li>hash值对数组长度取模，确定所属的桶；</li><li>在桶中插入key-value对；</li></ul><p>hash的性质保证了相同的hash值必然会映射到同一个桶中，通过在桶中遍历确定对应的key-value对。控制每个桶中key-value对的数量，保证map的几项操作都限制在常数级别的时间复杂度内。</p><p>map中，会对长度为2的整数次幂的桶数组进行key-value对的存储。每个桶固定存储8个kv对，当超过8个，就会创建桶链表。</p><p>由于hash冲突的存在，不同的key值可能会映射到相同的桶。解决hash冲突的方法一般有两种：拉链法和开放寻址法。</p><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><p>将命中同一个桶中的元素通过链表的方式进行链接，便于动态扩展。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>当再次命中同一个桶中是，会以一定的探测策略，寻找空闲的位置。</p><p>Golang map在实现hash冲突时，结合了拉链法和开放寻址法两种。以写流程举例：</p><ul><li>桶数组中的每个桶，严格意义上讲是一个桶单链表，链表上的每个节点都是一个桶</li><li>每个桶可以固定存储8个kv对</li><li>当key命中一个桶时，首先根据开放寻址法找到一个空闲的位置，如果当前桶节点没有空闲位置，通过桶节点的溢出指针到达下一个桶节点，重复上一个步骤</li><li>如果遍历到链表尾部仍然没有找到空闲位置，就新建一个桶节点，将kv对存储在其中</li></ul><h3 id="map扩容"><a href="#map扩容" class="headerlink" title="map扩容"></a>map扩容</h3><p>如果map中桶数组的长度不变的话，当插入的kv对达到一定数量的时候，每个索引下挂载的kv对数量就会过多，操作的常数时间复杂度就会逐渐退化成线性复杂度。此时就需要对桶数组进行扩容。</p><p>map扩容机制核心包括：</p><ul><li>扩容分为增量扩容和等量扩容；</li><li>当桶内kv总数/桶数组的长度 &gt; 6.5时发生增量扩容，桶数组的长度增长为原值的两倍；</li><li>当桶内溢出桶的数量大于等于2^B时（B为桶数组长度的指数，因为是2的整数次幂），发生等量扩容，桶的长度保持为原值；</li><li>采用渐进扩容，当桶被实际操作时，由使用者完成数据迁移，避免一次性的全量数据迁移导致的性能抖动；</li></ul><h2 id="Golang-channel实现原理"><a href="#Golang-channel实现原理" class="headerlink" title="Golang channel实现原理"></a>Golang channel实现原理</h2><p>Golang channel底层的核心数据结构包括一个环形数组（维护两个指针：一个是写入时的index，一个是读取时的index）、一个阻塞的读协程队列、一个阻塞的写协程队列（双向链表）。</p><p>根据类型，channel分为无缓冲型、有缓冲元素为struct型、有缓冲元素为pointer型。</p><ul><li>如果是无缓冲型，仅申请一个大小为默认值96的空间；</li><li>如果是有缓冲的struct型，一次性分配好96 + mem大小的空间，并且调整chan的buf（环形数组）指向mem的起始位置；</li><li>如果是有缓冲的pointer型，分别申请chan和buf的空间，两者无需连续；</li></ul><h3 id="写流程"><a href="#写流程" class="headerlink" title="写流程"></a>写流程</h3><p>针对写操作，对于未初始化的channel，写入操作会发生死锁，对于已经关闭的channel，写入操作会导致panic。</p><p>如果写时存在阻塞读协程（说明channel当前为空），首先加锁，然后从阻塞读协程队列中取出一个goroutine的封装对象，再者会基于memmove方法，将写入元素直接拷贝给对应取出的goroutine，然后解锁，最后唤醒阻塞的读协程。</p><p>如果写时无阻塞读协程但环形缓冲区仍有空间，加锁，将当前写入元素添加到环形缓冲区当中对应的位置（有特定的维护的index），然后将index后移，解锁，返回。</p><p>如果写时无阻塞读协程且环形缓冲区无空闲空间，加锁，构造封装当前goroutine的对象，将当前对象添加到当前channel的阻塞写协程队列中，然后挂起当前协程，如果协程被唤醒，（说明有对应读协程），最后解锁。</p><h3 id="读流程"><a href="#读流程" class="headerlink" title="读流程"></a>读流程</h3><p>如果读空channel，会挂起，引发死锁。</p><p>如果channel已经关闭，并且内部没有元素，直接解锁返回即可</p><p>如果读时有阻塞的写协程（说明当前的环形缓冲区已满或无缓冲），首先加锁，然后从写阻塞队列中获取一个写协程，如果无缓冲区，直接读取写协程的元素，唤醒写协程，如果存在缓冲区，则读取缓冲区头部的元素，再将写协程的元素添加到环形缓冲区的尾部并唤醒写协程，最后解锁返回。</p><p>如果读时无阻塞写协程且缓冲区有元素，加锁，获得缓冲区首部元素，将index++，解锁返回。</p><p>如果读时无阻塞写协程且缓冲区无元素，加锁，构造当前读goroutine的对象，添加到读阻塞协程队列，挂起当前协程，（如果协程从挂起状态中被唤醒，说明有元素写入），最后解锁。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>非阻塞模式下，读/写channel方法通过一个bool型的响应参数，用来标识是否读取/写入成功。</p><ul><li>所有使得当前goroutine被挂起的操作，在非阻塞模式下都会返回false；</li><li>所有使得当前goroutine会进入死锁的操作，在非阻塞模式下都会返回false；</li><li>所有能立即完成读取/写入操作的条件下，非阻塞模式下会返回true；</li></ul><p>只有在select语句组成的多路复用分支中，与channel的交互会变成非阻塞模式。</p><h2 id="Golang-new和make的区别"><a href="#Golang-new和make的区别" class="headerlink" title="Golang new和make的区别"></a>Golang new和make的区别</h2><p>new可以创建任何类型的变量，而make指可以创建引用类型（如切片、映射、通道）的变量，这是因为make会对变量进行初始化，而new不会。</p><p>new总是返回一个指向新内存的指针，而make返回的是引用类型的实例，即已经初始化后的变量。</p><p>new分配的内存会进行零值初始化，这意味着对于非指针类型，new返回的是该类型的零值，对于指针类型，new返回的是空指针。而make会为引用类型分配内存并初始化，例如为切片分配初始长度和容量，为映射分配哈希表等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis知识点总结</title>
      <link href="/2024/02/01/redis/"/>
      <url>/2024/02/01/redis/</url>
      
        <content type="html"><![CDATA[<h2 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h2><p>&emsp;&emsp;redis是一种基于内存的数据库。</p><h2 id="redis如何避免缓存雪崩、击穿、穿透？"><a href="#redis如何避免缓存雪崩、击穿、穿透？" class="headerlink" title="redis如何避免缓存雪崩、击穿、穿透？"></a>redis如何避免缓存雪崩、击穿、穿透？</h2><p>1、 缓存雪崩</p><p>&emsp;&emsp;通常为了保持缓存和数据库中数据的一致性。会给缓存中的key设置过期时间。当缓存数据过期后，用户访问的数据不在缓存中，就会去访问数据库，然后将数据更新到redis，使得后续能够直接命中缓存。</p><p>&emsp;&emsp;当大量缓存数据在同一时间失效，这时如果有大量的用户请求过来，都无法在redis中命中，这些请求只能都去访问数据库，极大加重数据库的压力，严重的话可能导致数据库崩溃，导致整个系统瘫痪，这样的问题称作缓存雪崩。</p><p>针对缓存崩溃问题，一般有两种解决方案：</p><ul><li>随机化缓存时间。这样可以降低集体缓存数据过期的概率</li><li>设置缓存不过期。通过后台服务来更新缓存，这样缓存不会过期，也就不会导致缓存雪崩</li></ul><p>2、缓存击穿</p><p>&emsp;&emsp;当热点数据过期，然后大量的用户请求该热点数据，此时无法在缓存中命中，就会转去访问数据库，数据库很容易被高并发的请求冲垮，这就是缓存击穿的问题。</p><p>解决方案：</p><ul><li>互斥锁，保证同一时刻只有一个业务线程请求缓存，如果本次未能获取锁，要么等待锁释放再访问缓存，要么直接返回空值或者默认值。</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据要过期之前通知后台线程更新缓存以及重新设立过期时间。</li></ul><p>3、 缓存穿透</p><p>&emsp;&emsp;当发生上述两种情况，数据库中仍然持有要访问的数据，一旦缓存中重新恢复数据，数据库的压力就会减轻。</p><p>假设一种情况，当访问的数据既不在缓存中，也不在数据库中，这时如果有大量类似的请求过来，数据库的压力就会骤增，这就是缓存穿透的问题。</p><p>针对缓存穿透问题，一般有三种解决方案：</p><ul><li>限制非法访问请求。在API入口处对请求参数进行检查，如果判断是恶意请求就直接返回错误，避免访问缓存和数据库</li><li>设置空值或者默认值。当发现缓存穿透的问题时，可以针对查询的数据，在缓存中设置空值或者默认值，这样后续请求就可以读到空值或者默认值返回给应用，而不会继续查询数据库</li><li>使用布隆过滤器。可以在写入数据库时布隆过滤器用来判断数据是否存在（假阳性）。这样即使发生了缓存穿透，也只是对缓存和布隆过滤器的大量访问，而不会涉及到大量查询数据库的操作，进而避免了缓存穿透。同时，redis本身也是支持布隆过滤器的。</li></ul><h2 id="redis中的缓存更新策略"><a href="#redis中的缓存更新策略" class="headerlink" title="redis中的缓存更新策略"></a>redis中的缓存更新策略</h2><p>redis中使用Cache Aside策略。应用程序直接与缓存和数据库进行交互，负责维护缓存，该策略可以细分为读策略和写策略。</p><p>写策略：</p><ul><li>先更新数据库中的数据</li><li>再删除缓存中的数据</li></ul><p>读策略：</p><ul><li>读取的数据直接命中缓存，直接返回</li><li>未命中，从数据库中读数据，然后写回缓存，并返回给用户</li></ul><p>Cache Aside适合读多写少的场景</p>]]></content>
      
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raft论文笔记</title>
      <link href="/2024/02/01/raft/"/>
      <url>/2024/02/01/raft/</url>
      
        <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>组织机器使其状态达成一致并允许局部失败的算法称为一致性算法。目的是为了保证集群中所有节点状态一致。<br>对节点的指令分为两种：读和写，只有写操作会改变节点的状态，所以为了一致，要把写指令同步给所有节点。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式系统、一致性算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络知识点回顾</title>
      <link href="/2024/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/"/>
      <url>/2024/02/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p>应用层 —&gt; 传输层 —&gt; 网络层 —&gt; 网络接口层</p><p>1、应用层</p><p>应用层专注为用户提供应用功能，如HTTP、FTP、Telnet、DNS、SMTP等。应用层工作在用户态下，而以下层工作在内核态下。</p><p>2、传输层</p><p>TCP/UDP就位于传输层。</p><p>TCP是可靠传输，有流量控制，超时重传，拥塞控制等特性；UDP是不可靠传输，只负责发送数据包，不保证其是否能安全抵达，因此其实时性更好、传输效率更高。</p><p>当应用层传来的数据超过MSS时，就要对数据进行分段，在TCP中，每一个称为TCP Segment。这样即使有分段丢失，可以重新传送，不用重发整个数据包。同时，当传输层要往应用层传数据时，用端口号将不同应用区分。特定的服务一般有特定的端口号，而浏览器中的每一个标签都是一个单独的进程，os会为这些进程临时分配端口号。</p><p>3、网络层</p><p>网络层通常使用的是IP协议。IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会再次进行分片，得到一个即将发送到网络的 IP 报文。</p><p>IP地址分为两部分：网络号 + 主机号。将IP地址和子网掩码进行按位与运算，可以得到网络号，将子网掩码取反后，再和IP地址按位与，可以得到主机号。</p><p>寻址过程中，先找到对应的子网，再在对应子网下查找主机。</p><p>IP还有一个能力就是路由。在网络中，两个设备之间可能要通过很多网关、路由器、交换机联系在一起。当数据包到达一个网络节点，就要根据路由算法来决定下一个目的地。</p><p>4、网络接口层</p><p>在IP头部前再加上MAC头，形成数据帧，发送到网络上。</p><p>MAC头部是以太网使用的头部，包含收发双方的MAC地址，可以通过ARP协议获得对方的MAC地址。</p><p>网络接口层主要为网络层提供链路级别的传输服务，负责在以太网、WiFi这种底层网络上传输数据，工作在网卡这个层次，使用MAC地址来标识网络上的设备。</p><h1 id="二、TCP篇"><a href="#二、TCP篇" class="headerlink" title="二、TCP篇"></a>二、TCP篇</h1><h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><ul><li>一开始，客户端和服务端都处于CLOSE状态，先是服务端主动监听某个端口，处于LISTEN状态。</li><li>客户端随机初始化序列号client-isn，将序号置于TCP首部，然后将TCP首部中的SYN标志置为1，接着发送第一个SYN包给服务端，表示发起连接，之后客户端处于SYN-SENT状态。</li><li>服务端收到来自客户端的SYN包后，首先服务端也随机初始化序列号server-isn，将序号置于TCP首部，然后把TCP首部中的确认号的字段中填入client-isn + 1，并将ACK和SYN标志置为1，然后把该报文发送给客户端，服务端进入SYN-RCVD状态。</li><li>客户端收到来自服务端的报文后，将TCP首部中的ACK标志置为1，且在确认字段中填入server-isn + 1，最后把报文发送给服务端，这次的报文可以携带从客户到服务端的数据，之后客户端处于ESTABLISHED状态。</li><li>服务端收到应答报文后，也进入ESTABLISHED状态。</li></ul><p>从上述过程中可以发现，第三次握手是可以携带数据的，前两次握手不携带数据。</p><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令</title>
      <link href="/2024/01/05/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2024/01/05/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="相对路径和绝对路径和特殊路径"><a href="#相对路径和绝对路径和特殊路径" class="headerlink" title="相对路径和绝对路径和特殊路径"></a>相对路径和绝对路径和特殊路径</h1><p>linux中/的含义有两种：一是根目录，二是表示层次</p><ul><li>绝对路径：从根目录开始，以根目录为起点，逐级往下</li><li>相对路径：从当前目录开始，以当前目录为起点，逐级往下</li><li>特殊路径：.代表当前目录，..代表上一级目录，~代表用户的home目录</li></ul><hr><h1 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h1><p>ls不使用参数，代表列出当前目录下的内容<br>-a,即all,代表列出全部文件(包含隐藏的文件或文件夹)(linux系统中前边为.的表示隐藏文件或文件夹)<br>-l,表示以竖向列表的形式展示当前目录下的内容，并且展示更多信息<br>-h,需要搭配-l一起使用，表示以人性化的方式展示文件大小</p><p>以上三个命令选项是可以组合使用的<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [-a -l -h] [linux路径]</span><br></pre></td></tr></table></figure></p><hr><h1 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h1><p>cd代表change directory，即改变当前工作目录<br>cd命令无需选项，只需参数，表示要切换到哪个目录下，cd命令不写参数，代表切换到用户的home目录<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [linux路径]</span><br></pre></td></tr></table></figure></p><hr><h1 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h1><p>pwd代表print work directory，即打印当前工作目录<br>pwd命令无需选项，只需参数，表示要打印哪个目录的路径<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd </span><br></pre></td></tr></table></figure></p><hr><h1 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h1><p>mkdir代表make directory，即创建目录<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [-p] linux路径</span><br></pre></td></tr></table></figure><br>-p,即parent,表示如果需要创建多层级的目录，则创建所有父目录</p><hr><h1 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h1><p>可以通过touch命令创建文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch linux路径</span><br></pre></td></tr></table></figure><br>touch命令无需选项，只需参数（表示创建的文件的路径）</p><hr><h1 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h1><p>准备好文件内容后可以通过cat命令查看文件内容<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat linux路径</span><br></pre></td></tr></table></figure><br>cat命令无需选项，只需参数（表示要查看的文件的路径）</p><hr><h1 id="more"><a href="#more" class="headerlink" title="more"></a>more</h1><p>more命令可以以分页的形式查看文件内容，如果文件内容过多可以一页页的展示<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more linux路径</span><br></pre></td></tr></table></figure><br>通过more查看文件内容的过程中，可以通过空格键翻页，通过q键退出查看文件内容的界面</p><hr><h1 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h1><p>cp代表copy，即复制文件或目录<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp [-r] 参数一 参数二</span><br></pre></td></tr></table></figure><br>-r,即recursive,表示递归复制，即复制目录时，复制目录下的所有内容(复制文件夹时使用)<br>参数一：表示要复制的文件或目录的路径<br>参数二：表示要复制到的路径</p><hr><h1 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h1><p>mv代表move，即移动文件或目录<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move 参数一 参数二</span><br></pre></td></tr></table></figure><br>参数一：表示要移动的文件或目录的路径<br>参数二：表示要移动到的路径（如果目标不存在，则起到改名的效果）</p><hr><h1 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h1><p>rm代表remove，即删除文件或目录<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [-r -f] 参数(可以有多个)   </span><br></pre></td></tr></table></figure><br>-r,即recursive,表示递归删除，即删除目录时，删除目录下的所有内容(删除文件夹时使用)<br>-f,即force,表示强制删除，即不询问直接删除(不会弹出提示确认信息)，普通用户删除内容后不会弹出提示，只有root管理员删除内容时会有提示，一般不同用户使用不到-f选项<br>参数：表示要删除的文件或目录的路径（多个参数之间用空格隔开）</p><hr><h1 id="which"><a href="#which" class="headerlink" title="which"></a>which</h1><p>linux命令本质上是一个个二进制可执行程序<br>which命令可以查看某个命令（即命令所对应的程序文件）的路径<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which 要查找的命令</span><br></pre></td></tr></table></figure></p><hr><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><p>find命令用于搜索指定的文件<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find 起始路径 -name &quot;要搜索的文件名&quot;(按文件名)</span><br><span class="line">find 起始路径 -size +|-n[kMG](按大小)</span><br></pre></td></tr></table></figure></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>东软云his技术栈总结</title>
      <link href="/2023/12/10/%E4%B8%9C%E8%BD%AF%E4%BA%91his%E6%8A%80%E6%9C%AF%E6%A0%88%E6%80%BB%E7%BB%93/"/>
      <url>/2023/12/10/%E4%B8%9C%E8%BD%AF%E4%BA%91his%E6%8A%80%E6%9C%AF%E6%A0%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇文章旨在记录大四小组实习实训期间项目所使用的技术栈，以及所使用的框架，框架的优缺点，以及框架的原理。同时对于在开发项目的过程中所遇到的问题和一些解决方案，以及一些技术点进行总结。</p><h1 id="1、项目主要技术栈以及开发工具"><a href="#1、项目主要技术栈以及开发工具" class="headerlink" title="1、项目主要技术栈以及开发工具"></a>1、项目主要技术栈以及开发工具</h1><h2 id="1-1、前端技术栈"><a href="#1-1、前端技术栈" class="headerlink" title="1.1、前端技术栈"></a>1.1、前端技术栈</h2><p>前端主要使用vue技术栈，vue技术栈的优点在于组件化，组件化使得代码可复用性高，组件化使得代码可维护性高，组件化使得代码可扩展性高。</p><h2 id="1-2、后端技术栈"><a href="#1-2、后端技术栈" class="headerlink" title="1.2、后端技术栈"></a>1.2、后端技术栈</h2><p>后端开发语言选择java，并主要使用springboot技术栈，springboot技术栈的优点在于快速开发，快速开发使得开发效率高，快速开发使得部署效率高，快速开发使得维护效率高。</p><h2 id="1-3、数据库"><a href="#1-3、数据库" class="headerlink" title="1.3、数据库"></a>1.3、数据库</h2><p>数据库使用mysql，mysql的优点在于开源，免费，使用成本低，mysql的缺点在于性能差，mysql的缺点在于数据量大的时候性能差。但对于该项目而言，mysql的优点大于缺点，已足够使用。</p><h2 id="1-4、开发工具"><a href="#1-4、开发工具" class="headerlink" title="1.4、开发工具"></a>1.4、开发工具</h2><p>开发工具使用：IntelliJ IDEA 2023.2.3，vscode，MySQL Workbench等。</p><hr><h1 id="2、架构设计"><a href="#2、架构设计" class="headerlink" title="2、架构设计"></a>2、架构设计</h1><h2 id="2-1、前后端分离架构设计"><a href="#2-1、前后端分离架构设计" class="headerlink" title="2.1、前后端分离架构设计"></a>2.1、前后端分离架构设计</h2><p>前后端分离架构设计，前端使用vue技术栈，后端使用springboot技术栈，前端和后端通过接口进行交互。</p><h2 id="2-2、业务架构设计"><a href="#2-2、业务架构设计" class="headerlink" title="2.2、业务架构设计"></a>2.2、业务架构设计</h2><p>业务架构设计，主要分为一下几个部分：</p><ul><li>用户管理模块</li><li>患者管理模块</li><li>医生管理模块</li><li>科室管理模块</li><li>挂号管理模块</li><li>处方管理模块</li><li>药房管理模块<br>具体就是分为基础信息维护、门诊挂号收费、门诊医生工作站、门诊医技工作站、门诊财务管理等。</li></ul><hr><h1 id="3、模块说明"><a href="#3、模块说明" class="headerlink" title="3、模块说明"></a>3、模块说明</h1><h2 id="3-1、-前端模块说明"><a href="#3-1、-前端模块说明" class="headerlink" title="3.1、 前端模块说明"></a>3.1、 前端模块说明</h2><ul><li>使用多种vue组件，实现了上述功能</li><li>引入动态路由，实现不同角色的权限分离，每个身份对应不用的Vue组件和路由</li><li>添加路由卫士，实现所有路由数据均由后端返回</li></ul><h2 id="3-2、-后端模块说明"><a href="#3-2、-后端模块说明" class="headerlink" title="3.2、 后端模块说明"></a>3.2、 后端模块说明</h2><ul><li>config:配置跨域支持，并且添加了MyBatis-Plus的分页插件，以便在数据库查询中使用分页功能</li><li>controller: 控制层包括医生、医技、动态菜单等业务逻辑的实现</li><li>entity: 实体层包括项目涉及到的所有类的定义</li><li>mapper: 数据层，用于与数据库的操作</li><li>service: 实现与前端交互</li><li>util: 一些自定义的工具类</li></ul><hr><h1 id="4、实现细节"><a href="#4、实现细节" class="headerlink" title="4、实现细节"></a>4、实现细节</h1><h2 id="4-1、-前端主要部分举例"><a href="#4-1、-前端主要部分举例" class="headerlink" title="4.1、 前端主要部分举例"></a>4.1、 前端主要部分举例</h2><h3 id="4-1-1、-路由"><a href="#4-1-1、-路由" class="headerlink" title="4.1.1、 路由"></a>4.1.1、 路由</h3><p>1、导入模块。<br>“Vue”和”VueRouter”分别是Vue.js核心库和Vue Router库<br>axios是一个用于发起HTTP请求的库，axios支持Promise，能轻松实现异步请求。store是VueX的数据存储仓库。<br>qs是一个用于序列化和解析URL参数的库。</p><p>2、使用插件<br>使用 VueRouter 插件，使 Vue 应用具备路由功能。<br>将 qs 库挂载到 Vue 原型上，以便在组件中使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">VueRouter</span>)</span><br><span class="line"><span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$qs</span> = qs;</span><br></pre></td></tr></table></figure></p><p>3、定义路由<br>定义一些路由规则，包括默认重定向、主页路径和登录路径。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  <span class="comment">// ... (路由配置)</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>4、创建路由实例<br>创建一个路由示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.<span class="property">env</span>.<span class="property">BASE_URL</span>,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>5、路由守卫<br>使用 beforeEach 路由守卫，用于在切换路由前执行一些逻辑。<br>在这里，判断是否有路由，如果没有，则从后端获取用户权限信息，并动态添加路由。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ... (路由守卫的逻辑)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>6、导航转为路由<br>定义了一个函数 menuToRoute 用于将菜单项转换为路由。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">menuToRoute</span> = (<span class="params">menu</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ... (导航转成路由的逻辑)&#125;</span></span><br></pre></td></tr></table></figure></p><p>7、导出路由示例<br>导出创建好的路由实例，以便在 Vue 应用中使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure></p><h3 id="4-1-2、-登录界面"><a href="#4-1-2、-登录界面" class="headerlink" title="4.1.2、 登录界面"></a>4.1.2、 登录界面</h3><p>使用Vue.js结合Element UI实现了用户登录功能。通过Vue.js和Element UI提供的组件和功能，实现了用户登录的表单验证和提交功能。Axios用于和后端进行数据交互，而Vuex则用于管理全局状态，包括用户Token信息。通过路由守卫实现了在用户登录成功后进行路由跳转。</p><h3 id="4-1-3、-主页"><a href="#4-1-3、-主页" class="headerlink" title="4.1.3、 主页"></a>4.1.3、 主页</h3><p>基于Vue.js和Element UI的前端页面，主要用于展示医疗系统的主界面，包括侧边栏、头部导航、用户信息和主体内容。<br>使用Vue.js构建前端单页面应用。利用Element UI组件库，例如el-container、el-aside、el-header、el-main等，来构建页面布局和各种UI元素。<br>利用Vue.js的组件化开发思想，将页面划分为多个组件，例如SideMenu、Tabs等，提高了代码的可维护性和可读性。<br>利用Vue Router进行前端路由管理，通过<router-view>标签动态加载视图组件。<br>使用Vuex进行状态管理，存储和管理全局状态，如用户信息。利用Element UI的栅格系统进行响应式布局，确保在不同屏幕尺寸下能够正常显示。</p><h3 id="4-1-4、-侧边栏菜单"><a href="#4-1-4、-侧边栏菜单" class="headerlink" title="4.1.4、 侧边栏菜单"></a>4.1.4、 侧边栏菜单</h3><p>1、<strong>模板部分</strong><br>使用了el-menu组件，设置了一些样式和属性，包括默认激活的菜单项、文本颜色、背景颜色等。<br>使用v-for指令遍历menuList，生成侧边栏菜单。menuList从Vuex中获取，即this.$store.state.menus.menuList。<br>使用router-link包裹el-menu-item，实现点击菜单项跳转到相应的路由。</p><p>2、<strong>脚本部分</strong><br>组件的名称为SideMenu。<br>在computed中使用计算属性menuList获取菜单列表，该菜单列表存储在Vuex的menus模块中的menuList属性中。</p><p>3、<strong>方法部分</strong><br>selectMenu方法用于处理菜单项的点击事件，通过$store.commit调用addTab mutation，将点击的菜单项添加到标签页中。<br>总体而言，实现了基于Element UI的垂直侧边栏菜单。菜单项来自于Vuex中的menuList，并且支持点击菜单项后在主体区域打开相应的路由页面。通过这种模块化的设计，可以方便地扩展和管理系统的菜单功能。</p><h3 id="4-1-5、-标签页"><a href="#4-1-5、-标签页" class="headerlink" title="4.1.5、 标签页"></a>4.1.5、 标签页</h3><p>1、<strong>模板部分</strong><br>使用了el-tabs组件，设置了一些属性，包括标签页的类型为card卡片形式、可关闭标签页、监听标签页的关闭事件（@tab-remove）和标签页的点击事件（@tab-click）。<br>使用v-for指令遍历editableTabs数组，生成可编辑的标签页。</p><p>2、<strong>脚本部分</strong><br>组件的名称为Tabs。<br>在data中没有声明任何局部状态，数据都是通过computed属性来获取和设置，这些数据来自于Vuex中的menus模块的editableTabs和editableTabsValue属性。<br>提供了两个计算属性：editableTabs和editableTabsValue，分别获取和设置Vuex中的相关数据。</p><p>3、<strong>方法部分</strong><br>removeTab方法用于处理标签页的关闭事件。在关闭标签页时，会更新editableTabs和editableTabsValue的值，并通过this.$router.push方法跳转到对应的路由页面。若关闭的是首页（’Index’），则直接返回不做任何操作。<br>clickTab方法用于处理标签页的点击事件。在点击标签页时，同样会通过this.$router.push方法跳转到对应的路由页面。</p><p>总体而言，实现了展示可编辑的标签页，标签页的内容由el-tab-pane组件承载，与路由进行关联，通过Vuex中的状态管理实现了标签页的动态增删和路由切换。</p><p>这里只节选部分功能进行说明。</p><h2 id="4-2-后端主要部分举例"><a href="#4-2-后端主要部分举例" class="headerlink" title="4.2 后端主要部分举例"></a>4.2 后端主要部分举例</h2><h3 id="4-2-1、-登录Controller"><a href="#4-2-1、-登录Controller" class="headerlink" title="4.2.1、 登录Controller"></a>4.2.1、 登录Controller</h3><p>这个控制器主要处理用户登录和登出的请求，通过注解映射相应的URL，并调用UserService处理业务逻辑，返回相应的结果给前端。</p><p>1、注解和依赖注入<br>@RestController：表明这是一个RESTful风格的控制器，返回的数据都是以JSON格式。@Autowired：自动注入UserService实例。</p><p>2、RequestMapping注解<br>@RequestMapping(“/login”)：映射处理来自前端的/login请求。<br>@RequestMapping(“/logout”)：映射处理来自前端的/logout请求。</p><p>3、login方法<br>处理用户登录请求。<br>使用@RequestMapping(“/login”)注解，接收前端传递的User对象参数。<br>打印接收到的前端数据和执行了登录的提示信息。<br>调用UserService的login方法，返回登录用户的信息。<br>判断登录用户是否为null，如果不为null，返回登录成功的结果；否则返回登录失败的结果。</p><p>4、logout方法<br>处理用户登出请求。<br>使用@RequestMapping(“/logout”)注解，接收前端传递的参数。<br>直接返回登出成功的结果。</p><p>5、返回方法<br>使用ResultUtil类构建返回结果，其中包括响应码（EnumCode）和消息。<br>登录成功时返回用户信息，登录失败和登出成功时只返回消息。</p><h3 id="4-2-2、-用户Controller"><a href="#4-2-2、-用户Controller" class="headerlink" title="4.2.2、 用户Controller"></a>4.2.2、 用户Controller</h3><p>这个控制器主要处理关于用户信息的查询请求，通过注解映射相应的URL，并调用UserService处理业务逻辑，返回相应的结果给前端。这样的设计使得代码更加模块化，实现了前后端的分离。</p><p>1、注解和依赖注入<br>@RestController：表明这是一个RESTful风格的控制器，返回的数据都是以JSON格式。<br>@Autowired：自动注入UserService实例。</p><p>2、RequestMapping注解<br>@RequestMapping(“/queryUserAll”)：映射处理来自前端的/queryUserAll请求。<br>@RequestMapping(“/queryUserDeptByID”)：映射处理来自前端的/queryUserDeptByID请求。</p><p>3、getUserAll方法<br>处理查询所有用户信息的请求。<br>使用@RequestMapping(“/queryUserAll”)注解，接收前端传递的User对象参数。<br>调用UserService的selectAll方法，返回所有用户的信息列表。<br>判断用户列表是否为null，如果不为null，返回查询成功的结果；否则返回查询失败的结果。</p><p>4、getUserDeptByID方法<br>处理根据用户ID查询用户所在部门信息的请求。<br>使用@RequestMapping(“/queryUserDeptByID”)注解，接收前端传递的User对象参数。<br>调用UserService的selectDeptByID方法，返回指定用户所在部门的信息。<br>判断部门信息是否为null，如果不为null，返回查询成功的结果；否则返回查询失败的结果。</p><p>这里也同样只挑出来一些比较有代表性的功能实现，还有其它一些功能这里就不再赘述了。</p><hr><h1 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h1><p>测试用浏览器：Chrome 113.0.5672.127<br>测试工具：Selenium(用于自动化浏览器操作的工具集和库，主要用于Web应用程序的测试，支持多种浏览器和多种操作系统)<br>测试报告框架：Allure(一种用于测试报告生成和测试结果可视化的开源测试报告框架)</p><h1 id="6、遇到的问题挑战"><a href="#6、遇到的问题挑战" class="headerlink" title="6、遇到的问题挑战"></a>6、遇到的问题挑战</h1><p>小组各成员在项目初期均对java不够熟悉，同时对于各种前后端框架的使用也不熟悉，学习成本比较高，在此处花费了大量的时间。同时该项目比较考验小组的协作分工能力，在项目初期成员分工不明确，导致项目进度比较缓慢，后期成员分工比较明确，项目进展比较顺利。</p><h1 id="7、项目总结"><a href="#7、项目总结" class="headerlink" title="7、项目总结"></a>7、项目总结</h1><p>通过这次小组合作项目，我们学到了很多东西，包括前后端分离、SpringBoot、SpringMVC、MyBatis、MySQL、Maven、Ajax、JSON、Javascript等技术，也提高了我们团队协作的能力，同时锻炼了我们独立思考的能力，相信对小组的各成员今后成长都有益处。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java, vue, springboot, mybatis, mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统原理笔记（一）——操作系统概述</title>
      <link href="/2023/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/"/>
      <url>/2023/08/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>操作系统笔记系列文章旨在记录学习操作系统的一些收获和感悟。《操作系统》是一门课程内容繁多且非常具有挑战性的一门课程，在这门课的学习中，抽出一些时间把王道书和《操作系统概念》书上的内容记录下来，这是为了让自己今后更好的回顾，也是为了分享给更多有需要的人。总之加油吧！<br>（os笔记分为原理和实验两个部分）</p><hr><h1 id="1、什么是操作系统"><a href="#1、什么是操作系统" class="headerlink" title="1、什么是操作系统"></a>1、什么是操作系统</h1><h2 id="1-1-操作系统的定义"><a href="#1-1-操作系统的定义" class="headerlink" title="1.1 操作系统的定义"></a>1.1 操作系统的定义</h2><ul><li>An operating system acts an intermediary between user of a computer and the computer hardware.<ul><li>操作系统充当计算机用户和计算机硬件之间的中介</li></ul></li><li>The purpose of an operating system is to provide an environment in which a user can execute programs in a convenient and efficient manner.<ul><li>操作系统的目的是提供一个用户可以方便和有效地执行程序的环境</li></ul></li><li>An operating system is software that manages the computer hardware.<ul><li>操作系统是管理计算机硬件的软件</li></ul></li></ul><p>综上所述，操作系统是指控制和管理整个计算机系统硬件与软件资源，合理地组织、调度计算机的工作和资源分配，进而为用户和其他软件提供方便接口与环境的程序集合。操作系统是计算机系统中最基本的系统软件。</p><h2 id="1-2-操作系统能做什么"><a href="#1-2-操作系统能做什么" class="headerlink" title="1.2 操作系统能做什么"></a>1.2 操作系统能做什么</h2><ul><li><strong>从用户角度</strong><ul><li>提供良好的用户界面</li><li>标准的函数库</li><li>使得编程更加方便并且不容易出错</li></ul></li><li><strong>从系统角度</strong><ul><li>管理资源<ul><li>硬件资源（处理机，存储器，设备）</li><li>信息资源（文件）</li></ul></li><li>解决申请资源时产生的冲突</li><li>阻止错误的产生和对计算机不正确的使用</li></ul></li></ul><h2 id="1-3-操作系统的特征"><a href="#1-3-操作系统的特征" class="headerlink" title="1.3 操作系统的特征"></a>1.3 操作系统的特征</h2><p>1、并发<br>操作系统的并发性是指计算机系统中同时存在多个运行的程序，因此它具有处理和调度多个程序同时执行的能力。<br>在操作系统中，引入进程的目的是使程序能并发执行。<br>注意并发（同一时间间隔）和并行（同一时刻）的区别。操作系统的并发性是通过分时得以实现。在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行，因此微观上这些程序仍是分时交替执行。而并行性是指操作系统具有同时进行运算或操作的特性，在同一时刻能完成两种或以上的工作。并行性需要硬件的支持，如多流水线或多处理机硬件环境。  </p><p>2、共享<br>系统中的资源可供内存中多个并发执行的进程共同使用。</p><ul><li>共享方式<ul><li>互斥共享方式：一段时间内只允许一个进程访问某资源</li><li>同时访问方式：某类资源允许在一段时间内由多个进程“同时”访问（宏观上）。</li></ul></li></ul><p>3、虚拟<br>指把一个物理上的实体变为若干逻辑上的对应物。操作系统中利用了多种虚拟处理技术来实现虚拟处理器、虚拟内存和虚拟外部设备等。操作系统的虚拟技术可归纳为：时分复用技术、空分复用技术。</p><p>4、异步<br>多道程序环境下，资源有限，进程的执行并不是一贯到底的，而是走走停停，已不可知的速度向前推进。</p><hr><h1 id="2、计算机系统组成"><a href="#2、计算机系统组成" class="headerlink" title="2、计算机系统组成"></a>2、计算机系统组成</h1><h2 id="2-1、计算机系统的架构"><a href="#2-1、计算机系统的架构" class="headerlink" title="2.1、计算机系统的架构"></a>2.1、计算机系统的架构</h2><p><img src="/post_img/1.png" alt="computer system organization" title="计算机操作系统的架构"></p><p>现代通用计算机系统包括一个或多个CPU和若干设备控制器，通过公用总线相连而成，该总线提供了共享内存的的访问。每个设备控制器负责一类特定的设备（如磁盘驱动、音频设备或视频显示器）。CPU与设备控制器可以并发执行，并且竞争访问内存。为了确保有序访问共享内存，需要内存控制器来协调访问内存。</p><h2 id="2-2、硬盘"><a href="#2-2、硬盘" class="headerlink" title="2.2、硬盘"></a>2.2、硬盘</h2><p>硬盘内部结构包括<strong>盘片</strong>、<strong>主轴</strong>、<strong>磁臂</strong>、<strong>磁头</strong>。当磁头要读写盘片数据时，磁臂移动到指定的磁道，等待要访问的数据点旋转到磁头下方。<br>盘片：磁性数据载体，分单面和双面<br>磁道：能被磁头访问的一组同心圆<br>扇区：数据存放的基本单位<br>柱面：所有盘片相同磁道构成的立体面<br>读操作：将从磁盘上读到的磁性转化为0或1<br>写操作：将0或1转化为相应的磁性写入磁盘</p><h2 id="2-3、存储系统（storage-system）"><a href="#2-3、存储系统（storage-system）" class="headerlink" title="2.3、存储系统（storage system）"></a>2.3、存储系统（storage system）</h2><p>CPU负责将指令从内存读入，所以程序必须在内存中才能执行。<br>内存以字节为存储单位，每个字节都有一个地址与之对应，通过load/store指令即可访问指定地址的内存数据。<br><img src="/post_img/2.png" alt="存储层次图"></p><h2 id="2-4、I-O结构"><a href="#2-4、I-O结构" class="headerlink" title="2.4、I/O结构"></a>2.4、I/O结构</h2><p>存储器属于I/O设备的一种，IO设备是计算机体系结构中种类最丰富的设备类型，具有很强的扩展性。<br>操作系统中有专门管理IO设备的一个专门的IO子系统。<br><img src="/post_img/3.png" alt="IO"></p><hr><h1 id="3、计算机系统体系结构"><a href="#3、计算机系统体系结构" class="headerlink" title="3、计算机系统体系结构"></a>3、计算机系统体系结构</h1><h2 id="3-1、单处理器系统（single-processor-system）"><a href="#3-1、单处理器系统（single-processor-system）" class="headerlink" title="3.1、单处理器系统（single-processor system）"></a>3.1、单处理器系统（single-processor system）</h2><p>只有一颗主CPU，执行通用指令集。带有其他专用处理器，为特定设备服务，如磁盘、键盘、图形控制器等（能够执行的指令有限，不处理用户进程，操作系统会向它们发出任务，监控状态）。</p><h2 id="3-2、多处理器系统（multiprocessor-multicore-system）"><a href="#3-2、多处理器系统（multiprocessor-multicore-system）" class="headerlink" title="3.2、多处理器系统（multiprocessor/multicore system）"></a>3.2、多处理器系统（multiprocessor/multicore system）</h2><p>有两个或多个紧密通信的CPU，共享计算机的总线、时钟、内存和外设等。<br>分为非对称处理和对称处理。</p><h2 id="3-3、集群系统（clustered-system）"><a href="#3-3、集群系统（clustered-system）" class="headerlink" title="3.3、集群系统（clustered system）"></a>3.3、集群系统（clustered system）</h2><p>该系统由若干节点（node）通过网络连接在一起，每个节点可为单处理器系统或多处理器系统，节点之间是松耦合关系。<br>具有高可用性和高性能计算的特点。</p><hr><h1 id="4、操作系统结构"><a href="#4、操作系统结构" class="headerlink" title="4、操作系统结构"></a>4、操作系统结构</h1><h2 id="4-1、单道批处理系统"><a href="#4-1、单道批处理系统" class="headerlink" title="4.1、单道批处理系统"></a>4.1、单道批处理系统</h2><p>系统对作业的处理是成批进行的，但内存中始终保持一道作业。</p><ul><li><strong>特征</strong><ul><li>自动性：一批作业能自动逐个进行，无需人工干预</li><li>顺序性：先调入内存的作业先完成</li><li>单道性：内存中仅有一道作业完成<br>面临的问题：内存每次仅存放一道作业，每当它在运行期间发出I/O请求后,CPU便处于等待I/O完成的状态。为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。</li></ul></li></ul><h2 id="4-2、多道批处理系统"><a href="#4-2、多道批处理系统" class="headerlink" title="4.2、多道批处理系统"></a>4.2、多道批处理系统</h2><p>多道程序设计技术允许多个程序同时进入内存并允许它们在CPU中交替运行，这些程序共享系统中的各种资源。当一道程序因I/O请求而暂停运行时，CPU立即转去运行另一道程序。实现系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。当然，多道批处理系统的设计与实现要比单道批处理系统复杂很多。</p><ul><li><strong>特征</strong><ul><li>多道：内存中同时存放多道相互独立的程序</li><li>宏观上并行：同时进入系统的多道程序都处于运行过程中</li><li>微观上串行：内存中的多道程序轮流占用CPU，交替执行<br>优点：资源利用率高，系统吞吐量大，缺点：用户响应时间较长；不提供人机交互能力，即用户不能了解程序的运行情况，也不能控制计算机。</li></ul></li></ul><h2 id="4-3、分时系统（time-sharing）"><a href="#4-3、分时系统（time-sharing）" class="headerlink" title="4.3、分时系统（time sharing）"></a>4.3、分时系统（time sharing）</h2><p>分时系统，也叫多任务系统（multitasking），是多道程序设计的自然延伸。</p><ul><li><p><strong>允许多个用户共享一台计算机</strong></p><ul><li>用户只有输入和输出设备</li><li>分时系统为每个用户轮流分配等量的CPU时间</li><li>用户从发出指令到得到即时结果的时间称为响应时间</li></ul></li><li><p><strong>特征</strong></p><ul><li>同时性：允许多个用户同时使用一台计算机</li><li>交互性：用户通过终端同程序进行交互</li><li>独立性：系统多个用户之间可以彼此独立操作，互不干扰</li><li>及时性：用户能在很短时间内获得响应</li></ul></li></ul><hr><h1 id="5、操作系统的服务"><a href="#5、操作系统的服务" class="headerlink" title="5、操作系统的服务"></a>5、操作系统的服务</h1><h2 id="5-1、操作系统提供的服务"><a href="#5-1、操作系统提供的服务" class="headerlink" title="5.1、操作系统提供的服务"></a>5.1、操作系统提供的服务</h2><p><img src="/post_img/4.png" alt="service"></p><ul><li>Almost all operating system have an user interface(UI).It offers a way of users to interface with OS.<ul><li>CLI(Command Line Interface)<ul><li>command interpreter(shell)</li></ul></li><li>GUI(Graphic User Interface)<ul><li>A user friendly graphical user interface.</li></ul></li><li>Batch<ul><li>It is a flie which contains commands and directives.</li></ul></li></ul></li></ul><h2 id="5-2、双重模式（Dual-Mode）"><a href="#5-2、双重模式（Dual-Mode）" class="headerlink" title="5.2、双重模式（Dual Mode）"></a>5.2、双重模式（Dual Mode）</h2><p>现代计算机系统有一个特殊的硬件，用于划分系统的运行状态，至少需要两种单独运行模式</p><ul><li>用户模式(user mode)：执行用户级代码（应用级）</li><li>内核模式(kernel mode)：执行操作系统级代码<br>实现方式：用一个硬件模式位来表示当前模式，0表示内核模式，1表示用户模式</li></ul><h2 id="5-3、系统调用（System-Calls）"><a href="#5-3、系统调用（System-Calls）" class="headerlink" title="5.3、系统调用（System Calls）"></a>5.3、系统调用（System Calls）</h2><p>系统调用提供了访问和使用操作系统所提供的服务的接口。系统调用的实现代码是操作系统级的，接口通常面向程序员。<br>API（Application Programming Interface）：指明了参数和返回值的一组函数。<br>通过API可以间接访问系统调用。</p><ul><li><strong>系统调用按功能分类</strong><ul><li>设备管理：完成设备的请求或释放，以及设备启动等功能</li><li>文件管理：完成文件的读、写、创建及删除等功能</li><li>进程管理：完成进程的创建、撤销、阻塞和唤醒的功能</li><li>进程通信：完成进程之间的消息传递或信号传递等功能</li><li>内存管理：完成内存的分配、回收以及获取作业占用内存区大小及始址等功能</li></ul></li></ul><p>系统调用的实现机制：每个系统调用都有一个唯一的数字编号，称为<strong>系统调用号</strong>。用户代码调用API时，API向系统调用接口指明其所要用的系统调用号，操作系统内核中维护了一张索引表，可以根据它来找到系统调用代码在操作系统中的位置。<br><img src="/post_img/5.png" alt="trap mechanism"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array</title>
      <link href="/2023/08/19/array/"/>
      <url>/2023/08/19/array/</url>
      
        <content type="html"><![CDATA[<p>数组是存放在连续内存空间上的相同类型数据的集合</p><p>vector底层实现是array，严格讲vector是容器而不是数组</p><p>数组元素不能删除，只能覆盖</p><p>c++中二维数组在地址空间上是连续的</p><h3 id="一、二分查找"><a href="#一、二分查找" class="headerlink" title="一、二分查找"></a>一、二分查找</h3><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><p>第一种写法：（左闭右闭）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;<span class="comment">//左闭右闭区间，允许left=right</span></span><br><span class="line">                <span class="type">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[middle] &gt; target)&#123;<span class="comment">//target在左区间，[left,middle-1]</span></span><br><span class="line">                    right = middle - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;<span class="comment">//target在右区间,[middle+1,right]</span></span><br><span class="line">                    left = middle + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//target在middle处</span></span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//目标值不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二种写法：（左闭右开）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="type">int</span> middle = (left + right) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[middle] &gt; target)&#123;</span><br><span class="line">                    right = middle;<span class="comment">//唯一不同之处在于target位于[left,middle)</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target)&#123;<span class="comment">//[middle+1,right)</span></span><br><span class="line">                    left = middle + <span class="number">1</span>; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> middle;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>区间的定义就是不变量，那么在循环中坚持根据查找区间的定义来做边界处理，就是循环不变量规则。</p><h3 id="二、移除元素"><a href="#二、移除元素" class="headerlink" title="二、移除元素"></a>二、移除元素</h3><p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p><p>暴力解法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;<span class="comment">//遍历数组</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] == val)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt; size - <span class="number">1</span>;j ++)&#123;<span class="comment">//执行移动操作</span></span><br><span class="line">                        nums[j] = nums[j + <span class="number">1</span>];<span class="comment">//后面元素覆盖前一个元素</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                i --;<span class="comment">//i下标后所有元素向前移动一位，i先减再加保持位置不变</span></span><br><span class="line">                size --;<span class="comment">//数组大小减一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h3><p>通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作</p><ul><li>快指针：寻找新数组的元素，新数组就是不包含目标值的数组</li><li>慢指针：指向更新 新数组下标的位置</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> slowIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> fastIndex = <span class="number">0</span>;fastIndex &lt; nums.<span class="built_in">size</span>();fastIndex ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[fastIndex] != val)&#123;<span class="comment">//快指针指向新数组值</span></span><br><span class="line">                    nums[slowIndex] = nums[fastIndex];<span class="comment">//将值赋给慢指针所指下标</span></span><br><span class="line">                    slowIndex ++;<span class="comment">//慢指针向右移动一位</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> slowIndex;<span class="comment">//删除完毕后慢指针下标所指值正好为新数组大小</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三、有序数组的平方"><a href="#三、有序数组的平方" class="headerlink" title="三、有序数组的平方"></a>三、有序数组的平方</h3><p>给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p><p>示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]</p><p>示例 2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121]</p><p>暴力解法：(每个数平方之后排序)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">                nums[i] *= nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">return</span> nums;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="双指针法-1"><a href="#双指针法-1" class="headerlink" title="双指针法"></a>双指针法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortSquare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(size,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="type">int</span> k = size - <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = size - <span class="number">1</span>;i &lt;= j;)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])&#123;</span><br><span class="line">                    result[k --] = nums[j] * nums[j];</span><br><span class="line">                    j --;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    result[k --] = nums[i] * nums[i];</span><br><span class="line">                    i ++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="四、长度最小的子数组"><a href="#四、长度最小的子数组" class="headerlink" title="四、长度最小的子数组"></a>四、长度最小的子数组</h3><p>给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。</p><p>暴力解法：</p><p>两层for循环，找到符合条件的子序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">minSubArrayLen</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> s)&#123;</span><br><span class="line">            <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">int</span> result = INT_MAX;<span class="comment">//记录最终结果</span></span><br><span class="line">           <span class="type">int</span> subLen = <span class="number">0</span>;<span class="comment">//记录子数组的长度</span></span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;<span class="comment">//记录子数组和</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;<span class="comment">//子数组初始位置i</span></span><br><span class="line">                sum = <span class="number">0</span>;<span class="comment">//新子数组和要清零</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j = i;j &lt; size;j ++)&#123;<span class="comment">//子数组终止位置j</span></span><br><span class="line">                    sum += nums[j];</span><br><span class="line">                    <span class="keyword">if</span>(sum &gt;= s)&#123;</span><br><span class="line">                        subLen = j - i + <span class="number">1</span>;<span class="comment">//子数组长度终止-初始+1</span></span><br><span class="line">                        result = result &lt; subLen ? result : subLen;<span class="comment">//保持结果长度最小</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;<span class="comment">//result未被赋值则返回0</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>所谓滑动窗口，<strong>就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果</strong>。</p><p>窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。</p><p>窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。</p><p>窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。</p><p>动态调整子数组的初始位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">subLen = j - i + <span class="number">1</span>;<span class="comment">//子数组长度</span></span><br><span class="line">    result = result &lt; subLen ? result : subLen;</span><br><span class="line">    sum -= nums[i ++];<span class="comment">//不断变更i（子数组的初始位置）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">            <span class="type">int</span> result = INT_MAX;</span><br><span class="line">            <span class="type">int</span> subLen = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>();j ++)&#123;</span><br><span class="line">                sum += nums[j];<span class="comment">//和&lt;s，向新数组加元素</span></span><br><span class="line">                <span class="keyword">while</span>(sum &gt;= s)&#123;</span><br><span class="line">                    subLen = j - i + <span class="number">1</span>;<span class="comment">//子数组长度</span></span><br><span class="line">                    result = result &lt; subLen ? result : subLen;</span><br><span class="line">                    sum -= nums[i ++];<span class="comment">//不断变更i（子数组的初始位置）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result == INT_MAX ? <span class="number">0</span> : result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h3><p>给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。</p><p>示例:</p><p>输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]</p><p>遵循循环不变量原则</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n)&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">res</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">            <span class="type">int</span> startx = <span class="number">0</span>,starty = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> loop = n / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> mid = n / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> offset = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> i,j;</span><br><span class="line">            <span class="keyword">while</span>(loop --)&#123;</span><br><span class="line">                <span class="keyword">for</span>(j = starty;j &lt; n - offset;j ++)&#123;</span><br><span class="line">                    res[startx][j] = count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(i = startx;i &lt; n - offset;i ++)&#123;</span><br><span class="line">                    res[i][j] = count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(;j &gt; starty;j --)&#123;</span><br><span class="line">                    res[i][j] = count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(;i &gt; startx;i --)&#123;</span><br><span class="line">                    res[i][j] = count ++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                startx ++;</span><br><span class="line">                starty ++;</span><br><span class="line">                offset ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                res[mid][mid] = n * n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note default simple"><p>binary-tree</p></div>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>binary tree</title>
      <link href="/2023/08/18/binary-tree/"/>
      <url>/2023/08/18/binary-tree/</url>
      
        <content type="html"><![CDATA[<h3 id="一、二叉树定义"><a href="#一、二叉树定义" class="headerlink" title="一、二叉树定义"></a>一、二叉树定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">        val = x;</span><br><span class="line">        <span class="keyword">this</span>.left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>.right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode()&#123;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val)&#123;<span class="built_in">this</span>.val = val;&#125;</span><br><span class="line">    TreeNode(<span class="type">int</span> val,TreeNode left,TreeNode right)&#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_init_</span>(<span class="params">self,value</span>):</span><br><span class="line">        self.value = value</span><br><span class="line">        self.left = <span class="literal">None</span></span><br><span class="line">        self.right = <span class="literal">None</span></span><br></pre></td></tr></table></figure><h3 id="二、递归"><a href="#二、递归" class="headerlink" title="二、递归"></a>二、递归</h3><p>1、确定递归函数的参数和返回值</p><p>2、确定终止条件</p><p>3、确定单层递归的逻辑</p><p>递归的实现：每一次递归调用都会把函数的局部变量，参数值，返回地址等压入调用栈中，等递归返回时，从栈顶弹出上一次递归的各项参数。</p><h4 id="前序遍历（递归）"><a href="#前序遍历（递归）" class="headerlink" title="前序遍历（递归）"></a>前序遍历（递归）</h4><p>打印遍历节点的值，除此之外无需返回其他值，函数返回类型为void,参数vec存储节点的数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure><p>本轮递归终止的条件是当前节点为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>前序遍历按照左中右顺序，先取中节点的值（单层递归）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur -&gt; val);<span class="comment">//中</span></span><br><span class="line"><span class="built_in">traversal</span>(cur -&gt; left,vec);<span class="comment">//左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur -&gt; right,vec);<span class="comment">//右</span></span><br></pre></td></tr></table></figure><p>前序遍历总过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                vec.<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">                <span class="built_in">traversal</span>(cur -&gt; left,vec);</span><br><span class="line">                <span class="built_in">traversal</span>(cur -&gt; right,vec);</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preordertraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; result;<span class="comment">//初始化一个vec</span></span><br><span class="line">            <span class="built_in">traversal</span>(root,result);<span class="comment">//从根节点开始遍历</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（递归）"><a href="#中序遍历（递归）" class="headerlink" title="中序遍历（递归）"></a>中序遍历（递归）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur -&gt; left,vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">    <span class="built_in">traversal</span>(cur -&gt; right,vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（递归）"><a href="#后序遍历（递归）" class="headerlink" title="后序遍历（递归）"></a>后序遍历（递归）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur -&gt; left,vec);</span><br><span class="line">    <span class="built_in">traversal</span>(cur -&gt; right,vec);</span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、迭代"><a href="#三、迭代" class="headerlink" title="三、迭代"></a>三、迭代</h3><h4 id="前序遍历（迭代）"><a href="#前序遍历（迭代）" class="headerlink" title="前序遍历（迭代）"></a>前序遍历（迭代）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; s;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> vec;</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node -&gt; val);<span class="comment">//栈顶节点值加入vec</span></span><br><span class="line">                <span class="keyword">if</span>(node -&gt; right)<span class="comment">//先压入右节点，空节点不执行</span></span><br><span class="line">                    s.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; left)<span class="comment">//后压入左节点，空节点不执行</span></span><br><span class="line">                    s.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（迭代）"><a href="#后序遍历（迭代）" class="headerlink" title="后序遍历（迭代）"></a>后序遍历（迭代）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Traversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                s.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                s.<span class="built_in">push</span>(node -&gt; right);<span class="comment">//遍历顺序改为中右左</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());<span class="comment">//逆序为左右中</span></span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前序遍历访问节点（遍历节点）和处理节点（将节点放入vec数组中）可以进行同步处理（既处理顺序和访问顺序一致），但是中序遍历无法同步</p><h4 id="中序遍历（迭代）"><a href="#中序遍历（迭代）" class="headerlink" title="中序遍历（迭代）"></a>中序遍历（迭代）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            stack&lt;TreeNode*&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">            TreeNode* cur = root;<span class="comment">//使用指针来进行节点访问</span></span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="literal">NULL</span>)&#123;<span class="comment">//指针访问节点，一直访问至二叉树最底层</span></span><br><span class="line">                    s.<span class="built_in">push</span>(cur);<span class="comment">//将访问节点放入栈</span></span><br><span class="line">                    cur = cur -&gt; left;<span class="comment">//左</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cur = s.<span class="built_in">top</span>();<span class="comment">//从栈顶弹出的数据即为需要处理的数据（放进vec数组中的数据）</span></span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(cur -&gt; val);<span class="comment">//中</span></span><br><span class="line">                    cur = cur -&gt; right;<span class="comment">//右</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>中序遍历先是访问根节点，再逐步向左向下访问节点直至到达最底层，进而再开始处理节点（将节点数值放入vec数组），导致访问顺序和处理数据顺序是不一样的。</p><h3 id="四、二叉树的统一迭代法"><a href="#四、二叉树的统一迭代法" class="headerlink" title="四、二叉树的统一迭代法"></a>四、二叉树的统一迭代法</h3><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            stack&lt;TreeNode*&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = s.<span class="built_in">top</span>();<span class="comment">//将该节点弹出，避免重复操作，下面再将右中左节点加入栈</span></span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        s.<span class="built_in">push</span>(node -&gt; right);<span class="comment">//非空右节点入栈</span></span><br><span class="line">                    s.<span class="built_in">push</span>(node);<span class="comment">//中节点入栈</span></span><br><span class="line">                    s.<span class="built_in">push</span>(<span class="literal">NULL</span>);<span class="comment">//此时中节点未进行处理，再其后加入NULL标记（表示待处理）</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        s.<span class="built_in">push</span>(node -&gt; left);<span class="comment">//非空左节点入栈</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//遇到空节点（即NULL标记）时，将下一个节点加入vec数组</span></span><br><span class="line">                    s.<span class="built_in">pop</span>();<span class="comment">//将空节点弹出</span></span><br><span class="line">                    node = s.<span class="built_in">top</span>();<span class="comment">//重新取出栈中元素</span></span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vec;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            stack&lt;TreeNode*&gt; s;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                s.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        s.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        s.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    s.<span class="built_in">push</span>(node);</span><br><span class="line">                    s.<span class="built_in">push</span>(<span class="literal">NULL</span>)</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    node = s.<span class="built_in">top</span>();</span><br><span class="line">                    s.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Traversal</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">            s.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                s.<span class="built_in">push</span>(node);</span><br><span class="line">                s.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                    s.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                    s.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                node = s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>到此，我们就将前中后序三种遍历用统一的代码风格写出来，关键在于加入NULL标记来表示需要处理的元素。</p><h3 id="五、二叉树的层序遍历"><a href="#五、二叉树的层序遍历" class="headerlink" title="五、二叉树的层序遍历"></a>五、二叉树的层序遍历</h3><p>层序遍历一个二叉树，就是一层一层从左往右进行遍历二叉树，需要借助数据结构遍历来实现，队列先进先出，符合一层一层遍历的逻辑，而使用栈先进后出适合深度优先遍历即递归的逻辑。</p><p>层序遍历是图论里的广度优先遍历。</p><h4 id="1、自上而下的层序遍历"><a href="#1、自上而下的层序遍历" class="headerlink" title="1、自上而下的层序遍历"></a>1、自上而下的层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root)&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;<span class="comment">//每层一个数组，每行合起来则是二维数组</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">                <span class="comment">//使用固定大小的size，而不用que.size()，因为que.size()会不断变化</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line">#递归法</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">order</span><span class="params">(TreeNode* cur,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(result.<span class="built_in">size</span>() == depth)</span><br><span class="line">                result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">            result[depth].<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">            <span class="built_in">order</span>(cur -&gt; left,result,depth + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">order</span>(cur -&gt; right,result,depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelorder</span>(TreeNode* root)&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">order</span>(root,result,depth);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、自底向上的层序遍历（将数组逆序然后输出）"><a href="#2、自底向上的层序遍历（将数组逆序然后输出）" class="headerlink" title="2、自底向上的层序遍历（将数组逆序然后输出）"></a>2、自底向上的层序遍历（将数组逆序然后输出）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">order</span>(TreeNode* root)&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        vec.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        vec.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">reserve</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());<span class="comment">//反转数组</span></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3、二叉树的右视图（从右看二叉树所能得到的节点值）"><a href="#3、二叉树的右视图（从右看二叉树所能得到的节点值）" class="headerlink" title="3、二叉树的右视图（从右看二叉树所能得到的节点值）"></a>3、二叉树的右视图（从右看二叉树所能得到的节点值）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSizeView</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(i ==<span class="built_in">z</span> (size - <span class="number">1</span>))</span><br><span class="line">                        result.<span class="built_in">push_back</span>(node -&gt; val);<span class="comment">//将每层最后一个元素放入result数组</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt;right);</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、二叉树的层平均值"><a href="#4、二叉树的层平均值" class="headerlink" title="4、二叉树的层平均值"></a>4、二叉树的层平均值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">averageOfLevels</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;<span class="type">double</span>&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="type">double</span> sum += node -&gt; val;<span class="comment">//统计每一层的和</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(sum / size);<span class="comment">//将每一层均值放入result数组中</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5、N叉树的层序遍历"><a href="#5、N叉树的层序遍历" class="headerlink" title="5、N叉树的层序遍历"></a>5、N叉树的层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root)&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;i &lt; node -&gt; children.<span class="built_in">size</span>();j ++)&#123;<span class="comment">//将节点孩子加入队列</span></span><br><span class="line">                        <span class="keyword">if</span>(node -&gt; children[j])</span><br><span class="line">                            que.<span class="built_in">push</span>(node -&gt; children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6、在每个二叉树行中找最大值"><a href="#6、在每个二叉树行中找最大值" class="headerlink" title="6、在每个二叉树行中找最大值"></a>6、在每个二叉树行中找最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="type">int</span> maxValue = INT_MIN;<span class="comment">//现将最大值设为INT_MIN(即整数最小)</span></span><br><span class="line">                <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    <span class="comment">//通过每一层不断比较，最终得到maxValue（即最大值）</span></span><br><span class="line">                    maxValue = ((node -&gt; val) &gt; maxValue)?node -&gt; val:maxValue;</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                result.<span class="built_in">push_back</span>(maxValue);<span class="comment">//将每一层的最大值加入数组result</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7、填充每一个节点的下一个右侧节点"><a href="#7、填充每一个节点的下一个右侧节点" class="headerlink" title="7、填充每一个节点的下一个右侧节点"></a>7、填充每一个节点的下一个右侧节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* next;<span class="comment">//指向节点的右侧节点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">connect</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                Node* preNode;<span class="comment">//用来记录首节点和前一个节点</span></span><br><span class="line">                Node* node;<span class="comment">//遍历节点</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                        preNode = que.<span class="built_in">front</span>();</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        node = preNode;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        node = que.<span class="built_in">front</span>();</span><br><span class="line">                        que.<span class="built_in">pop</span>();</span><br><span class="line">                        preNode -&gt; next = node;</span><br><span class="line">                        preNode  = preNode -&gt; next;<span class="comment">//= node同理</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(right);</span><br><span class="line">                &#125;</span><br><span class="line">                node -&gt; next = <span class="literal">NULL</span>;<span class="comment">//本层最后一个节点指向NULL</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8、二叉树的最大深度"><a href="#8、二叉树的最大深度" class="headerlink" title="8、二叉树的最大深度"></a>8、二叉树的最大深度</h4><p>给定一个二叉树，找出其最大深度</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数（叶子节点没有子节点）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth ++;<span class="comment">//记录深度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                    que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                    que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="9、二叉树的最小深度"><a href="#9、二叉树的最小深度" class="headerlink" title="9、二叉树的最小深度"></a>9、二叉树的最小深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                    <span class="comment">//当节点左右孩子都为空（即叶子节点），到达最小深度</span></span><br><span class="line">                    <span class="keyword">if</span>(!node -&gt; left &amp;&amp; !node -&gt; right)</span><br><span class="line">                        <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结，二叉树的层序遍历，就是图论中的广度优先搜索在二叉树中的应用，需要借助队列来实现。</p><h3 id="六、翻转二叉树"><a href="#六、翻转二叉树" class="headerlink" title="六、翻转二叉树"></a>六、翻转二叉树</h3><h4 id="1、深度优先遍历"><a href="#1、深度优先遍历" class="headerlink" title="1、深度优先遍历"></a>1、深度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归（前序遍历）</span></span><br><span class="line"><span class="comment">//先进行交换左右孩子节点，然后反转左子树，然后反转右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            <span class="built_in">swap</span>(root -&gt; left,root -&gt; right);<span class="comment">//中</span></span><br><span class="line">            <span class="built_in">invertTree</span>(root -&gt; left);<span class="comment">//左</span></span><br><span class="line">            <span class="built_in">invertTree</span>(root -&gt; right);<span class="comment">//右</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历（迭代）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = st.<span class="built_in">top</span>();<span class="comment">//中</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node -&gt; left,node -&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                    st.<span class="built_in">push</span>(node -&gt; right);<span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                    st.<span class="built_in">push</span>(node -&gt; left);<span class="comment">//左</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历（统一迭代法）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                st.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        st.<span class="built_in">push</span>(right);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        st.<span class="built_in">push</span>(left);</span><br><span class="line">                    st.<span class="built_in">push</span>(node);</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="built_in">swap</span>(node -&gt; left,node -&gt;right);<span class="comment">//节点处理逻辑</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2、广度优先遍历"><a href="#2、广度优先遍历" class="headerlink" title="2、广度优先遍历"></a>2、广度优先遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">;<span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="built_in">swap</span>(node -&gt; left,node -&gt; right);<span class="comment">//左右子树交换</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对二叉树的问题，解题之前要想清楚究竟选择哪种遍历方式</p><h3 id="七、对称二叉树"><a href="#七、对称二叉树" class="headerlink" title="七、对称二叉树"></a>七、对称二叉树</h3><p>给定一个二叉树，检查二叉树是否镜像对称</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自己的第一遍思考</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Tree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; que;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">            <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    vec.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; size;j ++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((vec[j] != vec[size - <span class="number">1</span> -j] || vec[j] == <span class="literal">NULL</span> || vec[size - <span class="number">1</span>-                         <span class="number">1</span> - j] == <span class="literal">NULL</span>)</span><br><span class="line">                       flag =<span class="number">1</span>;</span><br><span class="line">                       <span class="keyword">return</span> flag;       </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> flag;</span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>针对自己第一次实现的想法进行改进：首先判断二叉树是否对称，不需要加入根节点（遍历则需要加入），因为是否对称只和左右子树有关。同时鉴于对队列数据结构的不熟练，调用了vector数组来储存节点数值后在数组中进行比较（考虑麻烦了），直接对称的将左右子树的节点加入到队列中，两个两个一组弹出比较。还加了flag标记来输出bool数，直接true or false即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            que.<span class="built_in">push</span>(root -&gt; left);<span class="comment">//加入左子树头结点</span></span><br><span class="line">            que.<span class="built_in">push</span>(root -&gt; right);<span class="comment">//加入右子树头结点</span></span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* leftNode = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                TreeNode* rightNode = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(!leftNode &amp;&amp; !leftNode)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!leftNode || !rightNode || (leftNode -&gt; val != rightNode -&gt; val))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                </span><br><span class="line">                que.<span class="built_in">push</span>(leftNode -&gt; left);</span><br><span class="line">                que.<span class="built_in">push</span>(rightNode -&gt; right);</span><br><span class="line">                que.<span class="built_in">push</span>(leftNode -&gt; right);</span><br><span class="line">                que.<span class="built_in">push</span>(rightNode -&gt; left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归</p><p>1、确定递归参数和返回值</p><p>比较根节点的两个子树是否是互相翻转的，进而判断这个二叉树是否对称，比较的是左右两个子树，参数就是根节点的左子树头结点和右子树头结点。</p><p>返回值自然是bool类型。</p><p>2、确定终止条件</p><p>要比较两个节点的数值相不相等，首先要把两节点为空的情况搞清楚。</p><ul><li>左节点为空，右节点不为空</li><li>左节点不为空，右节点为空</li><li>左右节点都为空</li><li>左右节点都不为空但是值不相等   </li></ul><p>3、确定单层递归的逻辑</p><p>单层递归的逻辑就是两个节点都不为空且节点值相等的情况。</p><ul><li>比较外侧节点值是否相等：传入左节点的左孩子，右节点的右孩子</li><li>比较内侧节点值是否相等：传入左节点的右孩子，右节点的左孩子</li><li>如果左右都对称返回true，有一方不对称就返回false</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left,TreeNode* right)</span></span>&#123;</span><br><span class="line">            <span class="comment">//首先排除空节点的情况</span></span><br><span class="line">            <span class="keyword">if</span>(!left &amp;&amp; right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(left &amp;&amp; !right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!left &amp;&amp; !right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//排除空节点后，两节点值不相等的情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((left -&gt; val) != (right -&gt; val))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左子树：左，右子树：右</span></span><br><span class="line">            <span class="type">bool</span> outside = <span class="built_in">compare</span>(left -&gt; left,right -&gt; right);</span><br><span class="line">            <span class="comment">//左子树：右，右子树：左</span></span><br><span class="line">            <span class="type">bool</span> inside = <span class="built_in">compare</span>(left -&gt; right,right -&gt; left);</span><br><span class="line">            <span class="comment">//逻辑处理</span></span><br><span class="line">            <span class="type">bool</span> isSame = outside &amp;&amp; inside;</span><br><span class="line">            <span class="keyword">return</span> isSame;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">compare</span>(root -&gt; left,root -&gt; right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="八、二叉树的最大深度"><a href="#八、二叉树的最大深度" class="headerlink" title="八、二叉树的最大深度"></a>八、二叉树的最大深度</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> result;<span class="comment">//用来存储最大深度</span></span><br><span class="line">        <span class="comment">//函数返回值为void，非int，与计算节点数不同，深度不具有累加性</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getDepth</span><span class="params">(TreeNode* node,<span class="type">int</span> depth)</span></span>&#123;<span class="comment">//参数为当前节点，以及当前的深度</span></span><br><span class="line">            result = depth &gt; result ? depth : result;<span class="comment">//通过不断比较深度来更新深度的值</span></span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;<span class="comment">//左</span></span><br><span class="line">                depth ++;<span class="comment">//深度加一，因为向下了一层</span></span><br><span class="line">                <span class="built_in">getDepth</span>(node-&gt;left,depth);</span><br><span class="line">                depth --;<span class="comment">//回溯，因为右子树还未进行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;<span class="comment">//同理，右</span></span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="built_in">getDepth</span>(node-&gt;right,depth);</span><br><span class="line">                depth --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            <span class="built_in">getDepth</span>(root,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>迭代法中层序遍历最为合适，因为遍历的层数即是二叉树的深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                     que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>n叉树的最大深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">front</span>();</span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt; node -&gt; children.<span class="built_in">size</span>();j ++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(node -&gt; children[j])</span><br><span class="line">                            que.<span class="built_in">push</span>(node -&gt; children[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="九、二叉树的最小深度"><a href="#九、二叉树的最小深度" class="headerlink" title="九、二叉树的最小深度"></a>九、二叉树的最小深度</h3><p>最小深度是指根节点到最近叶子节点的最短路径上的节点个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>((!node -&gt; left) &amp;&amp; (!node -&gt; right))<span class="comment">//左右节点都为空时到达最小深度</span></span><br><span class="line">                        <span class="keyword">return</span> depth;</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                     que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十、完全二叉树的节点个数"><a href="#十、完全二叉树的节点个数" class="headerlink" title="十、完全二叉树的节点个数"></a>十、完全二叉树的节点个数</h3><p>将完全二叉树当作普通二叉树看待，依旧使用普通二叉树的遍历方法来计算节点个数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getNodeNums</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> leftNodeNums = <span class="built_in">getNodeNums</span>(root -&gt; left);<span class="comment">//左</span></span><br><span class="line">            <span class="type">int</span> rightNodeNums = <span class="built_in">getNodeNums</span>(root -&gt; right);<span class="comment">//右</span></span><br><span class="line">            <span class="type">int</span> nodeNums = leftNodeNums + rightNodeNums + <span class="number">1</span>;<span class="comment">//中</span></span><br><span class="line">            <span class="keyword">return</span> nodeNums;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getNodeNums</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;<span class="comment">//记录节点个数</span></span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    result ++;<span class="comment">//每遍历一个节点加一</span></span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; left);</span><br><span class="line">                    <span class="keyword">if</span>(node -&gt; right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node -&gt; right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然而，完全二叉树本省具有一些特性使得能够使用一些其它的方法来计算个数</p><p>在完全二叉树中，除了最底层的节点可能没有填满之外，其余每层节点数都达到最大值，并且最下面一层节点都集中在该层最左侧的若干区域，若最底层为第h层，则该层节点个数范围为1~2^(h-1)</p><p>完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。</p><p>对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。</p><p>对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。</p><p>可以看出如果整个树不是满二叉树，就递归其左右孩子，直到遇到满二叉树为止，用公式计算这个子树（满二叉树）的节点数量。</p><p>这里关键在于如何去判断一个左子树或者右子树是不是满二叉树呢？</p><p>在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            TreeNode* left = root -&gt; left;</span><br><span class="line">            TreeNode* right = root -&gt; right;</span><br><span class="line">            <span class="type">int</span> leftDepth = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> rightDepth = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left)&#123;</span><br><span class="line">                left = left -&gt; left;</span><br><span class="line">                leftDepth ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(right)&#123;</span><br><span class="line">                right = right -&gt; right;</span><br><span class="line">                rightDepth ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(leftDepth == rightDepth)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>^(leftDepth - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">countNodes</span>(root -&gt; left) + <span class="built_in">countNodes</span>(root -&gt; right) + <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十一、平衡二叉树"><a href="#十一、平衡二叉树" class="headerlink" title="十一、平衡二叉树"></a>十一、平衡二叉树</h3><p>因为求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）</p><p>一颗高度平衡的二叉树定义为：一个二叉树每个节点的左右两棵子树的高度差绝对值不超过1。</p><p>根据定义可知，如果以当前节点为传入节点的二叉树已经不是二叉树了，则该二叉树不是平衡二叉树</p><p>return -1来标记不符合平衡二叉树的规则。</p><p>递归思路：</p><p>1、明确递归函数的参数和返回值</p><p>参数：当前传入节点。 返回值：以当前传入节点为根节点的树的高度。</p><p>那么如何标记左右子树是否差值大于1呢？</p><p>如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。</p><p>所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。</p><p>2、明确终止条件</p><p>递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0</p><p>3、明确单层递归的逻辑</p><p>如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。</p><p>分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则返回-1，表示已经不是二叉平衡树了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)<span class="comment">//如果该节点是空指针，则高度为0</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//判断左右子树是否是平衡二叉树，有一个不是则非平衡二叉树</span></span><br><span class="line">            <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(leftHeight == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(LeftHeight == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(leftHeight - rightHeight) &gt; <span class="number">1</span>)&#123;<span class="comment">//左右子树高度差不超过1</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//取两树高度最大者在加上根节点的高度为整颗平衡二叉树的高度</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight,rightHeight) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">//node节点的最大深度就是node的高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            <span class="keyword">if</span>(node == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> depth = <span class="number">0</span>;<span class="comment">//记录深度</span></span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;<span class="comment">//更新最大深度值</span></span><br><span class="line">            st.<span class="built_in">push</span>(node);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    st.<span class="built_in">push</span>(cur);</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">                    depth ++;</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;right)</span><br><span class="line">                        st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;left)</span><br><span class="line">                        st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    node = st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                    depth --;</span><br><span class="line">                &#125;</span><br><span class="line">                result = result &gt; depth ? result : depth;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">               <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="built_in">getDepth</span>(node-&gt;left),<span class="built_in">getDepth</span>(node-&gt;right))&gt;<span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                    st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                    st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>求深度适合前序遍历，求高度适合后序遍历</p><h3 id="十二、二叉树的所有路径"><a href="#十二、二叉树的所有路径" class="headerlink" title="十二、二叉树的所有路径"></a>十二、二叉树的所有路径</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,vector&lt;<span class="type">int</span>&gt; path,vector&lt;string&gt; result)</span></span>&#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                string sPath;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; path.<span class="built_in">size</span>() - <span class="number">1</span>;i++)&#123;</span><br><span class="line">                    sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                    sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">                result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                <span class="built_in">traversal</span>(node-&gt;left,path,result);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                <span class="built_in">traversal</span>(node-&gt;right,path,result);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">            vector&lt;string&gt; result;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            <span class="built_in">traversal</span>(root,path,result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十三、左叶子之和"><a href="#十三、左叶子之和" class="headerlink" title="十三、左叶子之和"></a>十三、左叶子之和</h3><p>1、确定递归函数的参数和返回值</p><p>要判断左节点值之和，首先要传入根节点，返回值则为数值之和</p><p>2、确定终止条件</p><p>如果遍历到空节点，左叶子值为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>注意，只有当前节点遍历的是父节点，才能判断其子节点是不是左叶子。所以如果当前遍历的节点是叶子节点，那其左叶子也必定为0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>3、确定单层递归的逻辑</p><p>遇到左叶子节点时，记录数值，然后通过递归求取左子树左叶子之和和右子树左叶子之和。相当于整个树的左叶子之和</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> LeftValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left);<span class="comment">//左</span></span><br><span class="line">            <span class="comment">//当左子树只是一个左叶子节点的时候</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)</span><br><span class="line">                leftValue = root-&gt;left-&gt;val;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> rightValue = <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);<span class="comment">//右</span></span><br><span class="line">            <span class="type">int</span> sum = leftValue + rightValue;<span class="comment">//中</span></span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            stack&lt;TreeNode*&gt; st;</span><br><span class="line">            st.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)</span><br><span class="line">                    result += node-&gt;left-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                   st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                   st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十四、找树左下角的值"><a href="#十四、找树左下角的值" class="headerlink" title="十四、找树左下角的值"></a>十四、找树左下角的值</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; que;</span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">                que.<span class="built_in">push</span>(root);</span><br><span class="line">            <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++)&#123;</span><br><span class="line">                    TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                    <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                        result = node-&gt;val;<span class="comment">//每层取第一个节点的值</span></span><br><span class="line">                    que.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">                        que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                        que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;<span class="comment">//遍历完所有层后result里的值则为树左下角的值</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//定义全局变量</span></span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN;<span class="comment">//记录最大深度</span></span><br><span class="line">    <span class="type">int</span> result;<span class="comment">//记录树左下角的值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,<span class="type">int</span> depth)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!node-&gt;left &amp;&amp; !node-&gt;left)&#123;</span><br><span class="line">                <span class="keyword">if</span>(depth &gt; maxDepth)&#123;</span><br><span class="line">                    maxDepth = depth;</span><br><span class="line">                    result = node-&gt;val;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//traversal(node-&gt;left,depth + 1);</span></span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="built_in">traversal</span>(node-&gt;left,depth);</span><br><span class="line">                depth --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//traversal(node-&gt;right,depth + 1);</span></span><br><span class="line">                depth ++;</span><br><span class="line">                <span class="built_in">traversal</span>(node-&gt;right,depth);</span><br><span class="line">                depth --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">            <span class="built_in">traversal</span>(root,<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结：</p><p>1、递归求深度的写法，在<strong>平衡树二叉树</strong>中详细分析了深度应该怎么求，高度应该怎么求</p><p>2、递归中隐藏了回溯，在<strong>二叉树的所有路径</strong> 中讲解了究竟哪里使用了回溯，哪里隐藏了回溯</p><p>3、层次遍历，在<strong>层序遍历</strong>深度讲解了二叉树层序遍历。</p><h3 id="十五、路径总和I"><a href="#十五、路径总和I" class="headerlink" title="十五、路径总和I"></a>十五、路径总和I</h3><p>给定一个二叉树和目标和，判断该树是否存在根节点到叶子节点的路径，这条路径上的所有节点值相加等于目标和</p><p>递归：</p><p>1、确定函数返回值和参数</p><p>需要一个指针遍历二叉树，同时需要int参数来记录目标和，使用递减的方式，当某条路径上的result递减至0且到叶子节点时，说明该二叉树存在所有节点值相加等于目标和的路径</p><p>2、确定终止条件</p><p> 当和递减至0且遍历到叶子节点时，存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(result == <span class="number">0</span> &amp;&amp; !cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><p>当遇到叶子节点未满足条件时，不存在</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>3、确定单层递归的逻辑</p><p>先向左继续判断，不满足再向右继续判断，都不满足则不存在该路径</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cur-&gt;left)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">traversal</span>(cur-&gt;left,result - cur-&gt;left-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">traversal</span>(cur-&gt;right,result - cur-&gt;right-&gt;val))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,<span class="type">int</span> result)</span></span>&#123;<span class="comment">//记录当前节点和目标和</span></span><br><span class="line">            <span class="comment">//当和递减至0且遍历到叶子节点时，存在</span></span><br><span class="line">            <span class="keyword">if</span>(result == <span class="number">0</span> &amp;&amp; !cur-&gt;left &amp;&amp; !cur-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//当遇到叶子节点未满足条件时，不存在</span></span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;<span class="comment">//左</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">traversal</span>(cur-&gt;left,result - cur-&gt;left-&gt;val))<span class="comment">//包含回溯的逻辑</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)&#123;<span class="comment">//右</span></span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">traversal</span>(cur-&gt;right,result - cur-&gt;right-&gt;val))<span class="comment">//包含回溯的逻辑</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">/*将回溯过程体现出来代码可改为：</span></span><br><span class="line"><span class="comment">            if(cur-&gt;left)&#123;</span></span><br><span class="line"><span class="comment">            result -= cur-&gt;left-&gt;val;</span></span><br><span class="line"><span class="comment">            if(traversal(cur-&gt;left,result))</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">            result += cur-&gt;left-&gt;val;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(cur-&gt;right)&#123;</span></span><br><span class="line"><span class="comment">            result -= cur-&gt;right-&gt;val;</span></span><br><span class="line"><span class="comment">            if(traversal(cur-&gt;right,result))</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">            result += cur-&gt;right-&gt;val;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">traversal</span>(root,sum - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递归过程隐藏回溯，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traversal</span>(cur-&gt;left,result - cur-&gt;left-&gt;val);</span><br></pre></td></tr></table></figure><p>把result - cur-&gt;left-&gt;val直接作为参数传进函数，函数结束，result的数值并没有改变</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root,<span class="type">int</span> sum)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//此时栈里放的是pair&lt;节点指针，路径数值&gt;</span></span><br><span class="line">            stack&lt;pair&lt;TreeNode*,<span class="type">int</span>&gt;&gt; st;</span><br><span class="line">            st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*,<span class="type">int</span>&gt;(root,root-&gt;val));</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                pair&lt;TreeNode*,<span class="type">int</span>&gt; node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">//如果该节点是叶子节点，同时该路径数值等于sum，返回true</span></span><br><span class="line">                <span class="keyword">if</span>(!node.first-&gt;left &amp;&amp; !node.first-&gt;right &amp;&amp; sum == node.second)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">//右节点，压入节点的同时，记录路径数值</span></span><br><span class="line">                <span class="keyword">if</span>(node.first-&gt;right)</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*,<span class="type">int</span>&gt;(node.first-&gt;right,node.second +                           node.first-&gt;right-&gt;val));</span><br><span class="line">                <span class="comment">//左节点，压入节点的同时，记录路径数值</span></span><br><span class="line">                <span class="keyword">if</span>(node.first-&gt;left)</span><br><span class="line">                    st.<span class="built_in">push</span>(<span class="built_in">pair</span>&lt;TreeNode*,<span class="type">int</span>&gt;(node.first-&gt;left,node.second +                           node.first-&gt;left-&gt;val));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十六、路径总和II"><a href="#十六、路径总和II" class="headerlink" title="十六、路径总和II"></a>十六、路径总和II</h3><p>给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于目标和的路径</p><p>递归：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;<span class="comment">//记录所有和为sum的路径</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;<span class="comment">//记录单条遍历的路径</span></span><br><span class="line">        <span class="comment">//递归函数不需要返回值，因为要遍历整棵树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,<span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">            <span class="comment">//遇到叶子节点且找到和为sum的路径</span></span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; count == <span class="number">0</span>)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!cur-&gt;left &amp;&amp; !cur-&gt;right)</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)&#123;<span class="comment">//左</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(cur-&gt;left-&gt;val);</span><br><span class="line">                <span class="built_in">traversal</span>(cur-&gt;left,count - cur-&gt;left-&gt;val);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)&#123;<span class="comment">//右</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(cur-&gt;right-&gt;val);</span><br><span class="line">                <span class="built_in">traversal</span>(cur-&gt;right,count - cur-&gt;right-&gt;val);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*体现回溯的过程</span></span><br><span class="line"><span class="comment">            if(cur-&gt;left)&#123;</span></span><br><span class="line"><span class="comment">            path.push_back(cur-&gt;left-&gt;val);</span></span><br><span class="line"><span class="comment">            count -= cur-&gt;left-&gt;val;</span></span><br><span class="line"><span class="comment">            traversal(cur-&gt;left,count);//递归</span></span><br><span class="line"><span class="comment">            count += cur-&gt;left-&gt;val;//回溯</span></span><br><span class="line"><span class="comment">            path.pop_back();//回溯</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            if(cur-&gt;right)&#123;</span></span><br><span class="line"><span class="comment">            path.push_back(cur-&gt;left-&gt;val);</span></span><br><span class="line"><span class="comment">            count -= cur-&gt;right-&gt;val;</span></span><br><span class="line"><span class="comment">            traversal(cur-&gt;right,count);//递归</span></span><br><span class="line"><span class="comment">            count += cur-&gt;right-&gt;val;//回溯</span></span><br><span class="line"><span class="comment">            path.pop_back();//回溯</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findPathSum</span>(TreeNode* root,<span class="type">int</span> sum)&#123;</span><br><span class="line">            result.<span class="built_in">clear</span>();</span><br><span class="line">            path.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">          <span class="built_in">traversal</span>(root,sum - root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="十七、从中序与后序遍历序列构造二叉树"><a href="#十七、从中序与后序遍历序列构造二叉树" class="headerlink" title="十七、从中序与后序遍历序列构造二叉树"></a>十七、从中序与后序遍历序列构造二叉树</h3><p>根据一棵树的中序和后序遍历构造二叉树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder,vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">            <span class="comment">//第一步</span></span><br><span class="line">            <span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">//后序遍历数组的最后一个元素，就是当前的中间节点</span></span><br><span class="line">            <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">            TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> root;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> delimiterIndex = <span class="number">0</span>;delimiter &lt; inorder.<span class="built_in">size</span>();delimiterIndex ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(inorder[delimiterIndex] == rootValue)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(),inorder.begin()+delimiterIndex)</span></span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin()+delimiterIndex+<span class="number">1</span>,inorder.end())</span></span>;</span><br><span class="line">            </span><br><span class="line">            postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt;                                                                           <span class="title">leftPostorder</span><span class="params">(postorder.begin(),postorder.begin()+leftInorder.size())</span></span>;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function">            <span class="title">rightPostorder</span><span class="params">(postorder.begin()+leftInorder.size(),postorder.end())</span></span>;</span><br><span class="line">            </span><br><span class="line">            root-&gt;left = <span class="built_in">traversal</span>(leftInorder,leftPostorder);</span><br><span class="line">            root-&gt;right = <span class="built_in">traversal</span>(rightInorder,rightPostorder);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">bulidTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder,vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder == <span class="literal">NULL</span> || postorder == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder,postorder);</span><br><span class="line">        &#125;</span><br><span class="line">                        </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="十八、最大二叉树"><a href="#十八、最大二叉树" class="headerlink" title="十八、最大二叉树"></a>十八、最大二叉树</h3><p>给定一个不含重复元素的整数数组。最大二叉树定义如下：</p><p>1、二叉树的根是数组中的最大元素</p><p>2、左子树是通过数组中的最大值左边部分构造出的最大二叉树</p><p>3、右子树是通过数组中的最大值左边部分构造出的最大二叉树</p><p>给定的数组大小在[1,1000]之间</p><p>1、确定递归函数参数和返回值</p><p>参数传入的是存放元素的数组，返回该数组构造的二叉树的头节点，返回类型是指向节点的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaxBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br></pre></td></tr></table></figure><p>2、确定终止条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">    node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、确定单层递归逻辑</p><p>分三步：</p><p>一、找到数组中最大的值与其对应的下标，最大的值构造根节点，下标用来下一步分割数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[i] &gt; maxValue)&#123;</span><br><span class="line">        maxValue = nums[i];</span><br><span class="line">        maxValueIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Treenode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">node-&gt;val = maxValue;</span><br></pre></td></tr></table></figure><p>二、最大值所在下标左区间 构造左子树</p><p>需要判断maxValueIndex&gt;0,因为至少保证左区间至少有一个数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(maxValueIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">leftTree</span><span class="params">(nums.begin(),nums.begin()+maxValueIndex)</span></span>;</span><br><span class="line">    node-&gt;left = <span class="built_in">constructMaxBinaryTree</span>(leftTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三、最大值所在下标右区间 构造右子树</p><p>maxValue&lt;(nums.size()-1),保证右区间至少有一个数值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>))&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightTree</span><span class="params">(nums.begin()+maxValueIndex+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">    node-&gt;right = <span class="built_in">constructMaxBinaryTree</span>(rightTree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaxBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);<span class="comment">//构造中节点</span></span><br><span class="line">            <span class="comment">//当数组只剩下一个元素，即叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">                node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//找到数组中的最大值与其下标</span></span><br><span class="line">            <span class="type">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; maxValue)&#123;</span><br><span class="line">                    maxValue = nums[i];</span><br><span class="line">                    maxValueIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node-&gt;val = maxValue;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//确保左右区间至少有一个元素</span></span><br><span class="line">            <span class="keyword">if</span>(maxValueIndex &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">left</span><span class="params">(nums.begin(),nums.begin()+maxValueIndex)</span></span>;</span><br><span class="line">                node-&gt;left = <span class="built_in">constructMaxBinaryTree</span>(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxValueIndex &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">right</span><span class="params">(nums.begin()+maxValueIndex+<span class="number">1</span>,nums.end())</span></span>;</span><br><span class="line">                node-&gt;right = <span class="built_in">constructMaxBinaryTree</span>(right);</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上代码较为冗余，效率不高，每次分割数组后都要新定义vector，但是逻辑描述较为清晰</p><p>优化版：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">solution</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//在左闭右开区间[left,rihgt)，构造二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="comment">//分割点下标：maxValueIndex</span></span><br><span class="line">            <span class="type">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; right;i ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[maxValueIndex])</span><br><span class="line">                    maxValueIndex = i;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[maxValueIndex]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左闭右开[left,maxValueIndex)</span></span><br><span class="line">            node-&gt;left = <span class="built_in">traversal</span>(nums,left,maxValueIndex);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//左闭右开[maxValueIndex+1,right)</span></span><br><span class="line">            node-&gt;right = <span class="built_in">traversal</span>(nums,maxValueIndex+<span class="number">1</span>,right);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaxBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">            <span class="comment">//初始左闭右开区间[0,nums.size())</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">traversal</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、个人简介"><a href="#一、个人简介" class="headerlink" title="一、个人简介"></a>一、个人简介</h3><p>性别男，03在读大学生,爱好打篮球、乒乓球，有一点点追星（kpop）<br>目前主攻C++技术栈<br>梦想成为高性能算法工程师（虽然很遥远😂） 希望了解一些计算机底层的技术</p><h3 id="二、建站目的"><a href="#二、建站目的" class="headerlink" title="二、建站目的"></a>二、建站目的</h3><p>记录一下日常生活和学习过程<br>保存生活的点点滴滴，日子才更有盼头嘛😁</p><p><img src="https://images5.alphacoders.com/613/thumbbig-613927.webp" alt="pika"></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/custom.css"/>
      <url>/css/custom.css</url>
      
        <content type="html"><![CDATA[/* 鼠标样式 */#cursor {    position: fixed;    width: 16px;    height: 16px;    /* 这里改变跟随的底色 */    background: rgb(57, 197, 187);    border-radius: 8px;    opacity: 0.25;    z-index: 10086;    pointer-events: none;    transition: 0.2s ease-in-out;    transition-property: background, opacity, transform;  }    #cursor.hidden {    opacity: 0;  }    #cursor.hover {    opacity: 0.1;    transform: scale(2.5);    -webkit-transform: scale(2.5);    -moz-transform: scale(2.5);    -ms-transform: scale(2.5);    -o-transform: scale(2.5);  }    #cursor.active {    opacity: 0.5;    transform: scale(0.5);    -webkit-transform: scale(0.5);    -moz-transform: scale(0.5);    -ms-transform: scale(0.5);    -o-transform: scale(0.5);  }  :root {    --trans-light: rgba(255, 255, 255, 0.88);    --trans-dark: rgba(25, 25, 25, 0.88);    --border-style: 1px solid rgb(169, 169, 169);    /*--backdrop-filter: blur(5px) saturate(150%);*/  }    /* 首页文章卡片 */  #recent-posts > .recent-post-item {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 25px;    border: var(--border-style);  }    /* 首页侧栏卡片 */  #aside-content .card-widget {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border-radius: 18px;    border: var(--border-style);  }    /* 文章页、归档页、普通页面 */  div#post,  div#page,  div#archive {    background: var(--trans-light);    backdrop-filter: var(--backdrop-filter);    border: var(--border-style);    border-radius: 20px;  }    /* 导航栏 */  #page-header.nav-fixed #nav {    background: rgba(255, 255, 255, 0.75);    backdrop-filter: var(--backdrop-filter);  }    [data-theme="dark"] #page-header.nav-fixed #nav {    background: rgba(0, 0, 0, 0.7) !important;  }    /* 夜间模式遮罩 */  [data-theme="dark"] #recent-posts > .recent-post-item,  [data-theme="dark"] #aside-content .card-widget,  [data-theme="dark"] div#post,  [data-theme="dark"] div#archive,  [data-theme="dark"] div#page {    background: var(--trans-dark);  }      /* 夜间模式页脚页头遮罩透明 */  [data-theme="dark"] #footer::before {    background: transparent !important;  }  [data-theme="dark"] #page-header::before {    background: transparent !important;  }    /* 阅读模式 */  .read-mode #aside-content .card-widget {    background: rgba(158, 204, 171, 0.5) !important;  }  .read-mode div#post {    background: rgba(158, 204, 171, 0.5) !important;  }    /* 夜间模式下的阅读模式 */  [data-theme="dark"] .read-mode #aside-content .card-widget {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  [data-theme="dark"] .read-mode div#post {    background: rgba(25, 25, 25, 0.9) !important;    color: #ffffff;  }  /* 侧边栏个人信息卡片动态渐变色 */#aside-content > .card-widget.card-info {  background: linear-gradient(    -45deg,    #e8d8b9,    #eccec5,    #a3e9eb,    #bdbdf0,    #eec1ea  );  box-shadow: 0 0 5px rgb(66, 68, 68);  position: relative;  background-size: 400% 400%;  -webkit-animation: Gradient 10s ease infinite;  -moz-animation: Gradient 10s ease infinite;  animation: Gradient 10s ease infinite !important;}@-webkit-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@-moz-keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}@keyframes Gradient {  0% {    background-position: 0% 50%;  }  50% {    background-position: 100% 50%;  }  100% {    background-position: 0% 50%;  }}/* 黑夜模式适配 */[data-theme="dark"] #aside-content > .card-widget.card-info {  background: #191919ee;}/* 个人信息Follow me按钮 */#aside-content > .card-widget.card-info > #card-info-btn {  background-color: #3eb8be;  border-radius: 8px;}/* 页脚与头图透明 */#footer {  background: transparent !important;}#page-header {  background: transparent !important;}/* 白天模式遮罩透明 */#footer::before {  background: transparent !important;}#page-header::before {  background: transparent !important;}/* 夜间模式遮罩透明 */[data-theme="dark"] #footer::before {  background: transparent !important;}[data-theme="dark"] #page-header::before {  background: transparent !important;}/* 一级菜单居中 */#nav .menus_items {  position: absolute !important;  width: fit-content !important;  left: 50% !important;  transform: translateX(-50%) !important;}/* 子菜单横向展示 */#nav .menus_items .menus_item:hover .menus_item_child {  display: flex !important;}/* 这里的2是代表导航栏的第2个元素，即有子菜单的元素，可以按自己需求修改 */.menus_items .menus_item:nth-child(5) .menus_item_child {  left: -38px;}/* 日间模式不生效 */[data-theme="light"] #site-name,[data-theme="light"] #site-title,[data-theme="light"] #site-subtitle,[data-theme="light"] #post-info {  animation: none;}/* 夜间模式生效 */[data-theme="dark"] #site-name,[data-theme="dark"] #site-title {  animation: light_15px 10s linear infinite;}[data-theme="dark"] #site-subtitle {  animation: light_10px 10s linear infinite;}[data-theme="dark"] #post-info {  animation: light_5px 10s linear infinite;}/* 关键帧描述 */@keyframes light_15px {  0% {    text-shadow: #5636ed 0 0 15px;  }  12.5% {    text-shadow: #11ee5e 0 0 15px;  }  25% {    text-shadow: #f14747 0 0 15px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 15px;  }  50% {    text-shadow: #b347f1 0 0 15px;  }  62.5% {    text-shadow: #002afa 0 0 15px;  }  75% {    text-shadow: #ed709b 0 0 15px;  }  87.5% {    text-shadow: #39c5bb 0 0 15px;  }  100% {    text-shadow: #5636ed 0 0 15px;  }}@keyframes light_10px {  0% {    text-shadow: #5636ed 0 0 10px;  }  12.5% {    text-shadow: #11ee5e 0 0 10px;  }  25% {    text-shadow: #f14747 0 0 10px;  }  37.5% {    text-shadow: #f1a247 0 0 10px;  }  50% {    text-shadow: #f1ee47 0 0 10px;  }  50% {    text-shadow: #b347f1 0 0 10px;  }  62.5% {    text-shadow: #002afa 0 0 10px;  }  75% {    text-shadow: #ed709b 0 0 10px;  }  87.5% {    text-shadow: #39c5bb 0 0 10px;  }  100% {    text-shadow: #5636ed 0 0 10px;  }}@keyframes light_5px {  0% {    text-shadow: #5636ed 0 0 5px;  }  12.5% {    text-shadow: #11ee5e 0 0 5px;  }  25% {    text-shadow: #f14747 0 0 5px;  }  37.5% {    text-shadow: #f1a247 0 0 15px;  }  50% {    text-shadow: #f1ee47 0 0 5px;  }  50% {    text-shadow: #b347f1 0 0 5px;  }  62.5% {    text-shadow: #002afa 0 0 5px;  }  75% {    text-shadow: #ed709b 0 0 5px;  }  87.5% {    text-shadow: #39c5bb 0 0 5px;  }  100% {    text-shadow: #5636ed 0 0 5px;  }}@font-face {  /* 为载入的字体取名字(随意) */  font-family: 'YSHST';  /* 字体文件地址(相对或者绝对路径都可以) */  src: url(/font/优设好身体.woff2);  /* 定义加粗样式(加粗多少) */  font-weight: normal;  /* 定义字体样式(斜体/非斜体) */  font-style: normal;  /* 定义显示样式 */  font-display: block;}/* 翻页按钮居中 */#pagination {  width: 100%;  margin: auto;}/* 引入Unicode Font-class的线上资源*/@import "//at.alicdn.com/t/c/font_4217822_8n3z6c434px.css";/* 图标大小 */svg.icon {  width: 1.28em;  height: 1.28em;  vertical-align: -0.15em;  fill: currentColor;  overflow: hidden;}/* 挂绳小猫咪 */body::-webkit-scrollbar {  width: 0;}.neko {  width: 64px;  height: 64px;  background-image: url("https://bu.dusays.com/2022/07/20/62d812db74be9.png");  position: absolute;  right: 32px;  background-repeat: no-repeat;  background-size: contain;  transform: translateX(50%);  cursor: pointer;  font-family: tzy;  font-weight: 600;  font-size: 16px;  color: #6f42c1;  display: none;}.neko::after {  display: none;  width: 100px;  height: 100px;  background-image: url("https://bu.dusays.com/2022/07/20/62d812d95e6f5.png");  background-size: contain;  z-index: 9999;  position: absolute;  right: 50%;  text-align: center;  line-height: 100px;  top: -115%;}.neko.showMsg::after {  content: attr(data-msg);  display: block;  overflow: hidden;  text-overflow: ellipsis;}.neko:hover::after {  content: attr(data-msg);  display: block;  overflow: hidden;  text-overflow: ellipsis;}.neko.fontColor::after {  color: #333;}/*** @description: 滚动条样式  跟猫二选一*/@media screen and (max-width:992px) {  ::-webkit-scrollbar {      width: 8px !important;      height: 8px !important  }  ::-webkit-scrollbar-track {      border-radius: 2em;  }  ::-webkit-scrollbar-thumb {      background-color: rgb(255 255 255 / .3);      background-image: -webkit-linear-gradient(45deg, rgba(255, 255, 255, 0.1) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.1) 50%, rgba(255, 255, 255, 0.1) 75%, transparent 75%, transparent);      border-radius: 2em  }  ::-webkit-scrollbar-corner {      background-color: transparent  }}/* 雪花特效 */[data-theme="light"] #snow{  display: block;  position: fixed;  left: 0;  top: 0;  width: 100%;  height: 100%;  pointer-events: none;  z-index: -2;}/* 雪花黑夜模式不显示 */[data-theme="dark"] #snow{  display: none;}/* 新年侧边栏 */#newYear {  color: white;  padding: 0 !important;}#newYear p,#newYear h3 {  font-weight: normal;  color: inherit;  margin: 0;}#newYear .item-headline {  display: none;}#newYear-main {  min-height: 160px;  padding: 1rem;  position: relative;  border-radius: 12px;  background-image: url(https://tuchuang.voooe.cn/images/2023/01/02/tunian.webp);  background-size: cover;  background-position: center;}#newYear-main * {  position: relative;  line-height: 1.3;}#newYear-main .newYear-time {  font-weight: bold;  text-align: center;}#newYear-main .time,#newYear-main .happyNewYear {  font-size: 3.5rem;  margin: 1rem 0;  display: block;}#newYear-main .day {  font-size: 5rem;}#newYear-main .day .unit {  font-size: 1rem;}#newYear-main .mask {  position: absolute;  left: 0;  top: 0;  height: 100%;  width: 100%;  background-color: rgba(0, 0, 0, .1);}/* 滚动条样式 */::-webkit-scrollbar {  width: 8px;  height: 8px;}::-webkit-scrollbar-track {  background-color: rgba(73, 177, 245, 0.2);  border-radius: 2em;}::-webkit-scrollbar-thumb {  background-color: var(--theme-color);  background-image: -webkit-linear-gradient(    45deg,    rgba(255, 255, 255, 0.4) 25%,    transparent 25%,    transparent 50%,    rgba(255, 255, 255, 0.4) 50%,    rgba(255, 255, 255, 0.4) 75%,    transparent 75%,    transparent  );  border-radius: 2em;}::-webkit-scrollbar-corner {  background-color: transparent;}::-moz-selection {  color: #fff;  background-color: var(--theme-color);}/* 信息卡片彩带 */.author_top:hover {  background: url(https://tuchuang.voooe.cn/images/2023/01/02/snow.gif);  background-size: cover;}.card-info-avatar .author-status-box {  position: absolute;  bottom: 0;  left: calc(100% - 28px);  width: 28px;  height: 28px;  border: 1px solid #d0d7de;  border-radius: 2em;  background-color: #f8f8f8f8;  transition: 0.4s;  overflow: hidden;}[data-theme="dark"] .card-info-avatar .author-status-box {  background-color: #222222f2;  border: 1px solid #5c6060;}.card-info-avatar .author-status-box .author-status {  display: flex;  align-items: center;  justify-content: center;  height: 28px;  padding: 0 5px;}.card-info-avatar .author-status-box:hover {  width: 105px;}.card-info-avatar .author-status-box:hover .author-status span {  width: 105px;  margin-left: 4px;}.card-info-avatar .author-status-box .author-status span {  width: 0;  font-size: 12px;  height: 100%;  overflow: hidden;  text-overflow: ellipsis;  white-space: nowrap;  transition: 0.4s;}.card-widget .card-info-avatar {  display: inline-block;  position: relative;}/* 头像呼吸灯 */[data-theme="light"] .avatar-img {  animation: huxi_light 4s ease-in-out infinite;}[data-theme="dark"] .avatar-img {  animation: huxi_dark 4s ease-in-out infinite;}@keyframes huxi_light {  0% {    box-shadow: 0px 0px 1px 1px #e9f5fa;  }  50% {    box-shadow: 0px 0px 5px 5px #e9f5fa;  }  100% {    box-shadow: 0px 0px 1px 1px #e9f5fa;  }}@keyframes huxi_dark {  0% {    box-shadow: 0px 0px 1px 1px #39c5bb;  }  50% {    box-shadow: 0px 0px 5px 5px #39c5bb;  }  100% {    box-shadow: 0px 0px 1px 1px #39c5bb;  }}/* 帧率检测 */#fps {  position: fixed;  /* 指定位置 */  left: 10px;  bottom: 10px;  z-index: 1919810;}[data-theme="light"] #fps {  background-color: rgba(255, 255, 255, 0.85);  backdrop-filter: var(--backdrop-filter);  padding: 4px;  border-radius: 4px;}[data-theme="dark"] #fps {  background-color: rgba(0, 0, 0, 0.72);  backdrop-filter: var(--backdrop-filter);  padding: 4px;  border-radius: 4px;}/* 顶部加载条 */.pace {  -webkit-pointer-events: none;  pointer-events: none;  -webkit-user-select: none;  -moz-user-select: none;  user-select: none;  z-index: 2000;  position: fixed;  margin: auto;  top: 4px;  left: 0;  right: 0;  height: 8px;  border-radius: 8px;  width: 7rem;  background: #eaecf2;  border: 1px #e3e8f7;  overflow: hidden}.pace-inactive .pace-progress {  opacity: 0;  transition: .3s ease-in}.pace .pace-progress {  -webkit-box-sizing: border-box;  -moz-box-sizing: border-box;  -ms-box-sizing: border-box;  -o-box-sizing: border-box;  box-sizing: border-box;  -webkit-transform: translate3d(0, 0, 0);  -moz-transform: translate3d(0, 0, 0);  -ms-transform: translate3d(0, 0, 0);  -o-transform: translate3d(0, 0, 0);  transform: translate3d(0, 0, 0);  max-width: 200px;  position: absolute;  z-index: 2000;  display: block;  top: 0;  right: 100%;  height: 100%;  width: 100%;  /* linear-gradient(to right, #3494e6, #ec6ead) */  background: linear-gradient(to right, #43cea2, #3866ca);  animation: gradient 2s ease infinite;  background-size: 200%}.pace.pace-inactive {  opacity: 0;  transition: .3s;  top: -8px}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/readPercent.css"/>
      <url>/css/readPercent.css</url>
      
        <content type="html"><![CDATA[/* 返回顶部 */button#go-up #percent {    display: none;    font-weight: bold;    font-size: 15px !important;}button#go-up span {    font-size: 12px!important;    margin-right: -1px;}/* 鼠标滑动到按钮上时显示返回顶部图标 */button#go-up:hover i {    display: block !important;}button#go-up:hover #percent {    display: none !important;}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/rightmenu.css"/>
      <url>/css/rightmenu.css</url>
      
        <content type="html"><![CDATA[/* 右键菜单 */#rightMenu {    display: none;    position: fixed;    width: 160px;    height: fit-content;    top: 10%;    left: 10%;      /* 菜单面板背景色 */    background-color: var(--card-bg);      /* 菜单面板文字颜色 */    border: 1px solid var(--font-color);    border-radius: 8px;    z-index: 100;  }  #rightMenu .rightMenu-group {    padding: 7px 6px;  }  #rightMenu .rightMenu-group:not(:nth-last-child(1)) {    border-bottom: 1px solid var(--font-color);  }  #rightMenu .rightMenu-group.rightMenu-small {    display: flex;    justify-content: space-between;  }  #rightMenu .rightMenu-group .rightMenu-item {    height: 30px;    line-height: 30px;    border-radius: 8px;    transition: 0.3s;    color: var(--font-color);  }  #rightMenu .rightMenu-group.rightMenu-line .rightMenu-item {    display: flex;    height: 40px;    line-height: 40px;    padding: 0 4px;  }  #rightMenu .rightMenu-group .rightMenu-item:hover {      /* 鼠标悬浮选项颜色 */    background-color: var(--text-bg-hover);  }  #rightMenu .rightMenu-group .rightMenu-item i {    display: inline-block;    text-align: center;    line-height: 30px;    width: 30px;    height: 30px;    padding: 0 5px;  }  #rightMenu .rightMenu-group .rightMenu-item span {    line-height: 30px;  }    #rightMenu .rightMenu-group.rightMenu-line .rightMenu-item * {    height: 40px;    line-height: 40px;  }  .rightMenu-group.hide {    display: none;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/runtime.css"/>
      <url>/css/runtime.css</url>
      
        <content type="html"><![CDATA[/*电子钟字体*/@font-face {    font-family: 'UnidreamLED';    src: url("https://cdn.jsdelivr.net/npm/akilar-candyassets/fonts/UnidreamLED.ttf");    font-display: swap;  }  div#runtime {    width: 180px;    margin: auto;    color: #fff;    padding-inline: 5px;    border-radius: 10px;    background-color: rgba(0,0,0,0.7);    font-family: 'UnidreamLED';  }  [data-theme="dark"] div#runtime {    color: #28b4c8;    box-shadow: 0 0 5px rgba(28,69,218,0.71);    animation: flashlight 1s linear infinite alternate;  }  /*悬停显示徽标提示语*/  a.github-badge:hover:before {    position: fixed;    width: fit-content;    margin: auto;    left: 0;    right: 0;    top: 10%;    border-radius: 10px;    text-align: center;    z-index: 100;    content: attr(data-title);    font-size: 20px;    color: #fff;    padding: 10px;    background-color: var(--text-bg-hover);  }  [data-theme=dark] a.github-badge:hover:before {    background-color: rgba(18,18,18,0.8);  }  @-moz-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @-webkit-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @-o-keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }  @keyframes flashlight {    from {      box-shadow: 0 0 5px #1478d2;    }    to {      box-shadow: 0 0 2px #1478d2;    }  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/css/universe.css"/>
      <url>/css/universe.css</url>
      
        <content type="html"><![CDATA[/* 背景宇宙星光  */#universe{    display: block;    position: fixed;    margin: 0;    padding: 0;    border: 0;    outline: 0;    left: 0;    top: 0;    width: 100%;    height: 100%;    pointer-events: none;    /* 这个是调置顶的优先级的，-1在文章页下面，背景上面，个人推荐这种 */    z-index: -1;  }]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/cursor.js"/>
      <url>/js/cursor.js</url>
      
        <content type="html"><![CDATA[var CURSOR;Math.lerp = (a, b, n) => (1 - n) * a + n * b;const getStyle = (el, attr) => {    try {        return window.getComputedStyle            ? window.getComputedStyle(el)[attr]            : el.currentStyle[attr];    } catch (e) {}    return "";};class Cursor {    constructor() {        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    move(left, top) {        this.cursor.style["left"] = `${left}px`;        this.cursor.style["top"] = `${top}px`;    }    create() {        if (!this.cursor) {            this.cursor = document.createElement("div");            this.cursor.id = "cursor";            this.cursor.classList.add("hidden");            document.body.append(this.cursor);        }        var el = document.getElementsByTagName('*');        for (let i = 0; i < el.length; i++)            if (getStyle(el[i], "cursor") == "pointer")                this.pt.push(el[i].outerHTML);        document.body.appendChild((this.scr = document.createElement("style")));        // 这里改变鼠标指针的颜色 由svg生成        this.scr.innerHTML = `* {cursor: url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 8 8' width='8px' height='8px'><circle cx='4' cy='4' r='4' opacity='1.0' fill='rgb(57, 197, 187)'/></svg>") 4 4, auto}`;    }    refresh() {        this.scr.remove();        this.cursor.classList.remove("hover");        this.cursor.classList.remove("active");        this.pos = {curr: null, prev: null};        this.pt = [];        this.create();        this.init();        this.render();    }    init() {        document.onmouseover  = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.add("hover");        document.onmouseout   = e => this.pt.includes(e.target.outerHTML) && this.cursor.classList.remove("hover");        document.onmousemove  = e => {(this.pos.curr == null) && this.move(e.clientX - 8, e.clientY - 8); this.pos.curr = {x: e.clientX - 8, y: e.clientY - 8}; this.cursor.classList.remove("hidden");};        document.onmouseenter = e => this.cursor.classList.remove("hidden");        document.onmouseleave = e => this.cursor.classList.add("hidden");        document.onmousedown  = e => this.cursor.classList.add("active");        document.onmouseup    = e => this.cursor.classList.remove("active");    }    render() {        if (this.pos.prev) {            this.pos.prev.x = Math.lerp(this.pos.prev.x, this.pos.curr.x, 0.15);            this.pos.prev.y = Math.lerp(this.pos.prev.y, this.pos.curr.y, 0.15);            this.move(this.pos.prev.x, this.pos.prev.y);        } else {            this.pos.prev = this.pos.curr;        }        requestAnimationFrame(() => this.render());    }}(() => {    CURSOR = new Cursor();    // 需要重新获取列表时，使用 CURSOR.refresh()})();]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/readPercent.js"/>
      <url>/js/readPercent.js</url>
      
        <content type="html"><![CDATA[window.onscroll = percent;// 执行函数// 页面百分比function percent() {    let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度        b = Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight) - document.documentElement.clientHeight, // 整个网页高度        result = Math.round(a / b * 100), // 计算百分比        up = document.querySelector("#go-up") // 获取按钮    if (result <= 95) {        up.childNodes[0].style.display = 'none'        up.childNodes[1].style.display = 'block'        up.childNodes[1].innerHTML = result;    } else {        up.childNodes[1].style.display = 'none'        up.childNodes[0].style.display = 'block'    }}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/fps.js"/>
      <url>/js/fps.js</url>
      
        <content type="html"><![CDATA[if (window.localStorage.getItem("fpson") == undefined || window.localStorage.getItem("fpson") == "1") {    var rAF = function () {        return (            window.requestAnimationFrame ||            window.webkitRequestAnimationFrame ||            function (callback) {                window.setTimeout(callback, 1000 / 60);            }        );    }();    var frame = 0;    var allFrameCount = 0;    var lastTime = Date.now();    var lastFameTime = Date.now();    var loop = function () {        var now = Date.now();        var fs = (now - lastFameTime);        var fps = Math.round(1000 / fs);        lastFameTime = now;        // 不置 0，在动画的开头及结尾记录此值的差值算出 FPS        allFrameCount++;        frame++;        if (now > 1000 + lastTime) {            var fps = Math.round((frame * 1000) / (now - lastTime));            if (fps <= 5) {                var kd = `<span style="color:#bd0000">卡成ppt🤢</span>`            } else if (fps <= 15) {                var kd = `<span style="color:red">电竞级帧率😖</span>`            } else if (fps <= 25) {                var kd = `<span style="color:orange">有点难受😨</span>`            } else if (fps < 35) {                var kd = `<span style="color:#9338e6">不太流畅🙄</span>`            } else if (fps <= 45) {                var kd = `<span style="color:#08b7e4">还不错哦😁</span>`            } else {                var kd = `<span style="color:#39c5bb">十分流畅🤣</span>`            }            document.getElementById("fps").innerHTML = `FPS:${fps} ${kd}`;            frame = 0;            lastTime = now;        };        rAF(loop);    }    loop();} else {    document.getElementById("fps").style = "display:none!important"}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/runtime.js"/>
      <url>/js/runtime.js</url>
      
        <content type="html"><![CDATA[setInterval(() => {    let create_time = Math.round(new Date('2023-08-18 00:00:00').getTime() / 1000); //在此行修改建站时间    let timestamp = Math.round((new Date().getTime()) / 1000);    let second = timestamp - create_time;    let time = new Array(0, 0, 0, 0, 0);      var nol = function(h){      return h>9?h:'0'+h;    }    if (second >= 365 * 24 * 3600) {      time[0] = parseInt(second / (365 * 24 * 3600));      second %= 365 * 24 * 3600;    }    if (second >= 24 * 3600) {      time[1] = parseInt(second / (24 * 3600));      second %= 24 * 3600;    }    if (second >= 3600) {      time[2] = nol(parseInt(second / 3600));      second %= 3600;    }    if (second >= 60) {      time[3] = nol(parseInt(second / 60));      second %= 60;    }    if (second > 0) {      time[4] = nol(second);    }    if ((Number(time[2])<22) && (Number(time[2])>7)){      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/糖果屋-营业中-6adea8?style=social&logo=cakephp' title='距离百年老店也就差不到一百年~'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    else{      currentTimeHtml ="<img class='boardsign' src='https://img.shields.io/badge/糖果屋-打烊了-6adea8?style=social&logo=coffeescript' title='这个点了应该去睡觉啦，熬夜对身体不好哦'><div id='runtime'>" + time[0] + ' YEAR ' + time[1] + ' DAYS ' + time[2] + ' : ' + time[3] + ' : ' + time[4] + '</div>';    }    document.getElementById("workboard").innerHTML = currentTimeHtml;  }, 1000);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/title.js"/>
      <url>/js/title.js</url>
      
        <content type="html"><![CDATA[//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener('visibilitychange', function () {    if (document.hidden) {        //离开当前页面时标签显示内容        document.title = 'w(ﾟДﾟ)w 不要走！再看看嘛！';        clearTimeout(titleTime);    }    else {        //返回当前页面时标签显示内容        document.title = '♪(^∇^*)欢迎回来！' + OriginTitile;        //两秒后变回正常标题        titleTime = setTimeout(function () {            document.title = OriginTitile;        }, 2000);    }});]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/universe.js"/>
      <url>/js/universe.js</url>
      
        <content type="html"><![CDATA[function dark() {window.requestAnimationFrame=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame;var n,e,i,h,t=.05,s=document.getElementById("universe"),o=!0,a="180,184,240",r="226,225,142",d="226,225,224",c=[];function f(){n=window.innerWidth,e=window.innerHeight,i=.216*n,s.setAttribute("width",n),s.setAttribute("height",e)}function u(){h.clearRect(0,0,n,e);for(var t=c.length,i=0;i<t;i++){var s=c[i];s.move(),s.fadeIn(),s.fadeOut(),s.draw()}}function y(){this.reset=function(){this.giant=m(3),this.comet=!this.giant&&!o&&m(10),this.x=l(0,n-10),this.y=l(0,e),this.r=l(1.1,2.6),this.dx=l(t,6*t)+(this.comet+1-1)*t*l(50,120)+2*t,this.dy=-l(t,6*t)-(this.comet+1-1)*t*l(50,120),this.fadingOut=null,this.fadingIn=!0,this.opacity=0,this.opacityTresh=l(.2,1-.4*(this.comet+1-1)),this.do=l(5e-4,.002)+.001*(this.comet+1-1)},this.fadeIn=function(){this.fadingIn&&(this.fadingIn=!(this.opacity>this.opacityTresh),this.opacity+=this.do)},this.fadeOut=function(){this.fadingOut&&(this.fadingOut=!(this.opacity<0),this.opacity-=this.do/2,(this.x>n||this.y<0)&&(this.fadingOut=!1,this.reset()))},this.draw=function(){if(h.beginPath(),this.giant)h.fillStyle="rgba("+a+","+this.opacity+")",h.arc(this.x,this.y,2,0,2*Math.PI,!1);else if(this.comet){h.fillStyle="rgba("+d+","+this.opacity+")",h.arc(this.x,this.y,1.5,0,2*Math.PI,!1);for(var t=0;t<30;t++)h.fillStyle="rgba("+d+","+(this.opacity-this.opacity/20*t)+")",h.rect(this.x-this.dx/4*t,this.y-this.dy/4*t-2,2,2),h.fill()}else h.fillStyle="rgba("+r+","+this.opacity+")",h.rect(this.x,this.y,this.r,this.r);h.closePath(),h.fill()},this.move=function(){this.x+=this.dx,this.y+=this.dy,!1===this.fadingOut&&this.reset(),(this.x>n-n/4||this.y<0)&&(this.fadingOut=!0)},setTimeout(function(){o=!1},50)}function m(t){return Math.floor(1e3*Math.random())+1<10*t}function l(t,i){return Math.random()*(i-t)+t}f(),window.addEventListener("resize",f,!1),function(){h=s.getContext("2d");for(var t=0;t<i;t++)c[t]=new y,c[t].reset();u()}(),function t(){document.getElementsByTagName('html')[0].getAttribute('data-theme')=='dark'&&u(),window.requestAnimationFrame(t)}()};dark()]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/newYear.js"/>
      <url>/js/newYear.js</url>
      
        <content type="html"><![CDATA[let newYearTimer = null;var newYear = () => {    clearTimeout(newYearTimer);    if (!document.querySelector('#newYear')) return;    // 新年时间戳 and 星期对象    let newYear = new Date('2024-01-22 00:00:00').getTime() / 1000,        week = { 0: '周日', 1: '周一', 2: '周二', 3: '周三', 4: '周四', 5: '周五', 6: '周六' }    time();    // 补零函数    function nol(h) { return h > 9 ? h : '0' + h; };    function time() {        // 现在 时间对象        let now = new Date();        // 右下角 今天        document.querySelector('#newYear .today').innerHTML = now.getFullYear() + '-' + (now.getMonth() + 1) + '-' + now.getDate() + ' ' + week[now.getDay()]        // 现在与新年相差秒数        let second = newYear - Math.round(now.getTime() / 1000);        // 小于0则表示已经过年        if (second < 0) {            document.querySelector('#newYear .title').innerHTML = 'Happy New Year!';            document.querySelector('#newYear .newYear-time').innerHTML = '<span class="happyNewYear">新年快乐</p>';        } else {            // 大于0则还未过年            document.querySelector('#newYear .title').innerHTML = '距离2023年春节：'            // 大于一天则直接渲染天数            if (second > 86400) {                document.querySelector('#newYear .newYear-time').innerHTML = `<span class="day">${Math.ceil(second / 86400)}<span class="unit">天</span></span>`            } else {                // 小于一天则使用时分秒计时。                let h = nol(parseInt(second / 3600));                second %= 3600;                let m = nol(parseInt(second / 60));                second %= 60;                let s = nol(second);                document.querySelector('#newYear .newYear-time').innerHTML = `<span class="time">${h}:${m}:${s}</span></span>`;                // 计时                newYearTimer = setTimeout(time, 1000);            }        }    }    // 元宝飘落    jQuery(document).ready(function ($) {        $('#newYear').wpSuperSnow({            flakes: ['https://tuchuang.voooe.cn/images/2023/01/02/yb1.webp', 'https://tuchuang.voooe.cn/images/2023/01/02/yb2.webp', 'https://tuchuang.voooe.cn/images/2023/01/02/yb3.webp'],            totalFlakes: '100',            zIndex: '999999',            maxSize: '30',            maxDuration: '20',            useFlakeTrans: false        });    });}// Pjax适配：若没有开启Pjax这里直接是newYear()即可// 开了Pjax的用以下两句document.addEventListener('pjax:complete', newYear);document.addEventListener('DOMContentLoaded', newYear);]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/js/snow.js"/>
      <url>/js/snow.js</url>
      
        <content type="html"><![CDATA[if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {    // 移动端不显示} else {    // document.write('<canvas id="snow" style="position:fixed;top:0;left:0;width:100%;height:100%;z-index:-2;pointer-events:none"></canvas>');    window && (() => {        let e = {            flakeCount: 50, // 雪花数目            minDist: 150,   // 最小距离            color: "255, 255, 255", // 雪花颜色            size: 1.5,  // 雪花大小            speed: .5,  // 雪花速度            opacity: .7,    // 雪花透明度            stepsize: .5    // 步距        };        const t = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {            window.setTimeout(e, 1e3 / 60)        }            ;        window.requestAnimationFrame = t;        const i = document.getElementById("snow"),            n = i.getContext("2d"),            o = e.flakeCount;        let a = -100,            d = -100,            s = [];        i.width = window.innerWidth,            i.height = window.innerHeight;        const h = () => {            n.clearRect(0, 0, i.width, i.height);            const r = e.minDist;            for (let t = 0; t < o; t++) {                let o = s[t];                const h = a,                    w = d,                    m = o.x,                    c = o.y,                    p = Math.sqrt((h - m) * (h - m) + (w - c) * (w - c));                if (p < r) {                    const e = (h - m) / p,                        t = (w - c) / p,                        i = r / (p * p) / 2;                    o.velX -= i * e,                        o.velY -= i * t                } else                    o.velX *= .98,                        o.velY < o.speed && o.speed - o.velY > .01 && (o.velY += .01 * (o.speed - o.velY)),                        o.velX += Math.cos(o.step += .05) * o.stepSize;                n.fillStyle = "rgba(" + e.color + ", " + o.opacity + ")",                    o.y += o.velY,                    o.x += o.velX,                    (o.y >= i.height || o.y <= 0) && l(o),                    (o.x >= i.width || o.x <= 0) && l(o),                    n.beginPath(),                    n.arc(o.x, o.y, o.size, 0, 2 * Math.PI),                    n.fill()            }            t(h)        }            , l = e => {                e.x = Math.floor(Math.random() * i.width),                    e.y = 0,                    e.size = 3 * Math.random() + 2,                    e.speed = 1 * Math.random() + .5,                    e.velY = e.speed,                    e.velX = 0,                    e.opacity = .5 * Math.random() + .3            }            ;        document.addEventListener("mousemove", (e => {            a = e.clientX,                d = e.clientY        }        )),            window.addEventListener("resize", (() => {                i.width = window.innerWidth,                    i.height = window.innerHeight            }            )),            (() => {                for (let t = 0; t < o; t++) {                    const t = Math.floor(Math.random() * i.width)                        , n = Math.floor(Math.random() * i.height)                        , o = 3 * Math.random() + e.size                        , a = 1 * Math.random() + e.speed                        , d = .5 * Math.random() + e.opacity;                    s.push({                        speed: a,                        velX: 0,                        velY: a,                        x: t,                        y: n,                        size: o,                        stepSize: Math.random() / 30 * e.stepsize,                        step: 0,                        angle: 180,                        opacity: d                    })                }                h()            }            )()    }    )();}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movie/index.html"/>
      <url>/movie/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
