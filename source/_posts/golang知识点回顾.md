---
title: redis知识点总结
date: 2024-2-1 8:25:00
update: 2023-8-25 8:25:00
tags: redis
cover: https://images5.alphacoders.com/124/thumbbig-1240551.webp
---

## Golang内存模型
golang内存分配参考了tcmalloc的思路，即thread cache malloc。tcmalloc分为ThreadCache、CentralCache和PageHeap三个层次。

ThreadCache是对每一个线程的缓存，分配时不需要加锁，因为是每一个线程独有的，速度较快。其对每一个size class维护一个freeList，缓存没有被分配的空闲对象。

CentralCache也对每个size class维护一个freeList，但是是被多个线程共享的，分配时需要加锁。

当CentralCache不够分配时，就会像PageHeap申请内存，这部分内存可能来自PageHeap的缓存，也有可能是PageHeap向操作系统申请的新内存。

tcmalloc减少了在多线程的环境下，争夺锁所产生的开销，原因主要有二：1、在ThreadCache层面，此时是被每个线程单独占有的，不需要申请锁，加快了速度；2、由于是一次性向操作系统申请了一大块内存，就不需要频繁的系统调用来申请内存（系统调用需要上下文切换，开销比价大），加快了内存分配的效率。

Golang内存管理组件主要包括mspan、mcache、mcentral、mheap。

当程序初始化的时候，每个processor会给微对象和小对象分配mcache，其中包含内存管理单元mspan。内存管理单元分为很多特定大小的类（从8B到32KB），当向mcache中内存大小不够的时候，就会向mcentral中申请内存，mcentral就会根据对应的mspan的类型进行分配。mcentral又属于mheap，mheap负责向操作系统申请内存。

### mspan
mspan是Golang内存分配的基本单元。有67种类型。
- 微对象。大小为（0， 16B），会先从微型分配器中分配，再依次尝试mcache、mcentral、mheap
- 小对象。大小为【16B、32KB】，申请顺序依次为mcache、mcentral、mheap
- 大对象。大小32KB以上，直接在mheap上分配

mspan结构体中包含prev和next两个指针，用于访问双向链表中的前驱和后继节点（指的是在freeList中）

span直译为跨度，可以理解为一段连续的内存。mspan包含多个大小为8KB的页，这里的页并非操作系统中的页，是它们大小的整数倍。

结构体中还包含spanclass字段，用来表示mspan的类型和大小，go中一共有67种span类型，每个spanclass存储特定大小的对象，所有的数据会预先计算出来并存储下来，便于查找，以空间换时间。除开这67种spanclass，还有0号spanclass，用来管理大于32KB的对象。

### mcache
go中的线程缓存，其与go中的processor绑定，每个线程都会分配一个mcache处理微对象和小对象，是每个线程独有的，不需要加锁。   

mcache在初始化时不包含mspan，只有当第一次申请内存时，会向上一级组件申请获得mspan

### mcentral
是Golang中的中心缓存，和mcache的区别是被多个线程共享，访问mcentral中的内存管理单元需要使用互斥锁。

每个mcentral会管理某个spanclass的内存管理单元，会分为两类，一个是包含空闲对象的内存管理单元，一个是不包含空闲管理对象的内存管理单元。

### mheap
内存分配的核心组件。包含mcentral和heapArena，堆上所有的mspan都是由mheap而来。
- allspans：已经分配的所有mspan
- arenas：heapArena数组，用于管理一个个内存块
- central：mcentral数组，用于管理对应spanclass的mspan

### 总结
Go的内存分配器根据对象的大小：分为微对象、小对象和大对象，分别采取不同的分配策略。

总体分配流程：32KB以上的对象，直接从mheap中进行分配；小于等于16KB的对象从mcache中的微型分配器中进行分配；剩下的小对象的话，首先计算对象的大小，然后mcache分配对应规格的mspan，如果mcache中没有对应规格的mspan，就会向mcentral中申请，若mcentral中也没有，就会继续向mheap申请，如果mheap中也没有，就会向操作系统进行申请。

## Golang map实现原理
算法上基于hash实现key的映射和寻址；在数据结构上基于桶数组实现key-value对的存储。

流程：
- 通过hash取得key的hash值；
- hash值对数组长度取模，确定所属的桶；
- 在桶中插入key-value对；

hash的性质保证了相同的hash值必然会映射到同一个桶中，通过在桶中遍历确定对应的key-value对。控制每个桶中key-value对的数量，保证map的几项操作都限制在常数级别的时间复杂度内。

map中，会对长度为2的整数次幂的桶数组进行key-value对的存储。每个桶固定存储8个kv对，当超过8个，就会创建桶链表。

由于hash冲突的存在，不同的key值可能会映射到相同的桶。解决hash冲突的方法一般有两种：拉链法和开放寻址法。

### 拉链法
将命中同一个桶中的元素通过链表的方式进行链接，便于动态扩展。

### 开放寻址法
当再次命中同一个桶中是，会以一定的探测策略，寻找空闲的位置。



Golang map在实现hash冲突时，结合了拉链法和开放寻址法两种。以写流程举例：
- 桶数组中的每个桶，严格意义上讲是一个桶单链表，链表上的每个节点都是一个桶
- 每个桶可以固定存储8个kv对
- 当key命中一个桶时，首先根据开放寻址法找到一个空闲的位置，如果当前桶节点没有空闲位置，通过桶节点的溢出指针到达下一个桶节点，重复上一个步骤
- 如果遍历到链表尾部仍然没有找到空闲位置，就新建一个桶节点，将kv对存储在其中

### map扩容
如果map中桶数组的长度不变的话，当插入的kv对达到一定数量的时候，每个索引下挂载的kv对数量就会过多，操作的常数时间复杂度就会逐渐退化成线性复杂度。此时就需要对桶数组进行扩容。

map扩容机制核心包括：
- 扩容分为增量扩容和等量扩容；
- 当桶内kv总数/桶数组的长度 > 6.5时发生增量扩容，桶数组的长度增长为原值的两倍；
- 当桶内溢出桶的数量大于等于2^B时（B为桶数组长度的指数，因为是2的整数次幂），发生等量扩容，桶的长度保持为原值；
- 采用渐进扩容，当桶被实际操作时，由使用者完成数据迁移，避免一次性的全量数据迁移导致的性能抖动；

## Golang channel实现原理
Golang channel底层的核心数据结构包括一个环形数组（维护两个指针：一个是写入时的index，一个是读取时的index）、一个阻塞的读协程队列、一个阻塞的写协程队列（双向链表）。

根据类型，channel分为无缓冲型、有缓冲元素为struct型、有缓冲元素为pointer型。
- 如果是无缓冲型，仅申请一个大小为默认值96的空间；
- 如果是有缓冲的struct型，一次性分配好96 + mem大小的空间，并且调整chan的buf（环形数组）指向mem的起始位置；
- 如果是有缓冲的pointer型，分别申请chan和buf的空间，两者无需连续；

### 写流程
针对写操作，对于未初始化的channel，写入操作会发生死锁，对于已经关闭的channel，写入操作会导致panic。

如果写时存在阻塞读协程（说明channel当前为空），首先加锁，然后从阻塞读协程队列中取出一个goroutine的封装对象，再者会基于memmove方法，将写入元素直接拷贝给对应取出的goroutine，然后解锁，最后唤醒阻塞的读协程。

如果写时无阻塞读协程但环形缓冲区仍有空间，加锁，将当前写入元素添加到环形缓冲区当中对应的位置（有特定的维护的index），然后将index后移，解锁，返回。

如果写时无阻塞读协程且环形缓冲区无空闲空间，加锁，构造封装当前goroutine的对象，将当前对象添加到当前channel的阻塞写协程队列中，然后挂起当前协程，如果协程被唤醒，（说明有对应读协程），最后解锁。

### 读流程
如果读空channel，会挂起，引发死锁。

如果channel已经关闭，并且内部没有元素，直接解锁返回即可

如果读时有阻塞的写协程（说明当前的环形缓冲区已满或无缓冲），首先加锁，然后从写阻塞队列中获取一个写协程，如果无缓冲区，直接读取写协程的元素，唤醒写协程，如果存在缓冲区，则读取缓冲区头部的元素，再将写协程的元素添加到环形缓冲区的尾部并唤醒写协程，最后解锁返回。

如果读时无阻塞写协程且缓冲区有元素，加锁，获得缓冲区首部元素，将index++，解锁返回。

如果读时无阻塞写协程且缓冲区无元素，加锁，构造当前读goroutine的对象，添加到读阻塞协程队列，挂起当前协程，（如果协程从挂起状态中被唤醒，说明有元素写入），最后解锁。

### 非阻塞模式
非阻塞模式下，读/写channel方法通过一个bool型的响应参数，用来标识是否读取/写入成功。
- 所有使得当前goroutine被挂起的操作，在非阻塞模式下都会返回false；
- 所有使得当前goroutine会进入死锁的操作，在非阻塞模式下都会返回false；
- 所有能立即完成读取/写入操作的条件下，非阻塞模式下会返回true；

只有在select语句组成的多路复用分支中，与channel的交互会变成非阻塞模式。

## Golang new和make的区别
new可以创建任何类型的变量，而make指可以创建引用类型（如切片、映射、通道）的变量，这是因为make会对变量进行初始化，而new不会。

new总是返回一个指向新内存的指针，而make返回的是引用类型的实例，即已经初始化后的变量。

new分配的内存会进行零值初始化，这意味着对于非指针类型，new返回的是该类型的零值，对于指针类型，new返回的是空指针。而make会为引用类型分配内存并初始化，例如为切片分配初始长度和容量，为映射分配哈希表等。